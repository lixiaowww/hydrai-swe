<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HydrAI-SWE Enhanced System - Snow Water Equivalent & Runoff Prediction</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script>
        // Global chart instances (only declare missing ones)
        let sweAnalysisChart = null;
        
        // Fix for 'exports is not defined' error in browser environment
        window.exports = {};
        window.module = { exports: window.exports };
        
        // Ensure Chart.js is available globally
        if (typeof Chart === 'undefined') {
            console.warn('Chart.js not loaded, charts may not work properly');
        }
        
        // Main tab switching functionality - moved here to be available before HTML
        function showMainTab(tabName) {
            // Hide all main content sections
            document.querySelectorAll('.main-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all main tabs
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected content
            document.getElementById(tabName + '-content').classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }
        
        // Global error handler to catch any remaining issues
        window.addEventListener('error', function(e) {
            console.error('Global error caught:', e.error);
            if (e.error && e.error.message && e.error.message.includes('exports is not defined')) {
                console.warn('Exports error detected, attempting recovery...');
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }
        
        .logo-svg {
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .logo-text {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .logo h1 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            line-height: 1.2;
            letter-spacing: -0.3px;
        }
        

        
        .subtitle-swe {
            font-size: 0.75rem;
            color: #7f8c8d;
            font-weight: 400;
            margin-left: 0.8rem;
            letter-spacing: 0.2px;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }

        .nav-links a {
            text-decoration: none;
            color: #555;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .nav-links a:hover {
            background: #f8f9fa;
            color: #4A90E2;
        }

        .nav-links a.active {
            background: #4A90E2;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        /* Single column layout for main content */
        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        /* Two column layout for smaller cards */
        .two-column-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        /* Three column layout for metrics */
        .three-column-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(31, 38, 135, 0.45);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #f1f3f4;
        }

        .card-header i {
            font-size: 1.5rem;
            color: #4A90E2;
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-green { background: #27ae60; }
        .status-orange { background: #f39c12; }
        .status-blue { background: #3498db; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .metric-item {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .metric-item:hover {
            transform: scale(1.05);
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
            display: block;
        }

        .metric-label {
            font-size: 0.85rem;
            color: #7f8c8d;
            margin-top: 0.3rem;
        }


        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .input-group label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        .number-input {
            padding: 0.75rem;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .number-input:focus {
            outline: none;
            border-color: #4A90E2;
        }

        .agri-results {
            min-height: 120px;
            margin-top: 1rem;
        }

        .chart-container {
            position: relative;
            height: 300px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #495057;
            font-weight: 500;
            border: 2px dashed #dee2e6;
            transition: all 0.3s ease;
            overflow: hidden;
            max-width: 100%;
            box-sizing: border-box;
        }

        .chart-container:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: #4A90E2;
        }
        
        /* Ensure charts don't overflow */
        .chart-container canvas {
            max-width: 100% !important;
            height: auto !important;
            display: block;
        }
        
        /* Factors Discovery Module Styles */
        .factors-discovery .chart-container {
            height: 300px;
            margin: 15px 0;
            border: 2px solid #e9ecef;
            background: #f8f9fa;
            overflow: hidden;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .factors-discovery h5 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-weight: 600;
        }
        
        .factors-discovery .row {
            margin-bottom: 25px;
        }
        
        .factors-discovery .row:last-child {
            margin-bottom: 0;
        }

        /* Actual chart display area */
        .chart-display {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        /* Simulated chart background */
        .chart-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, 
                rgba(74, 144, 226, 0.1) 0%, 
                rgba(39, 174, 96, 0.1) 50%, 
                rgba(52, 152, 219, 0.1) 100%);
        }

        /* Chart placeholder styling */
        .chart-placeholder {
            z-index: 2;
            text-align: center;
            padding: 2rem;
        }

        .chart-placeholder i {
            font-size: 3rem;
            color: #4A90E2;
            margin-bottom: 1rem;
            display: block;
        }

        .chart-placeholder .chart-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .chart-placeholder .chart-subtitle {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .data-table th,
        .data-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4A90E2, #667eea);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .alert {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .btn {
            background: linear-gradient(135deg, #4A90E2, #667eea);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .full-width {
            grid-column: 1 / -1;
        }

        /* 语言选择器样式已移除，减少CSS体积 */

        /* Forecast Controls Styles */
        .forecast-controls {
            display: flex;
            gap: 2rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .forecast-options {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .forecast-options label {
            font-weight: 600;
            color: #495057;
        }

        .forecast-select {
            padding: 0.5rem 1rem;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background: white;
            min-width: 150px;
        }

        .forecast-select:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.1);
        }

        /* Date Range Selector Styles */
        .date-range-selector {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .date-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .date-group label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        .date-input {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
            min-width: 140px;
        }

        .date-input:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.1);
        }

        .date-presets {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .preset-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .preset-btn:hover {
            background: #e9ecef;
        }

        .preset-btn.active {
            background: #4A90E2;
            color: white;
            border-color: #4A90E2;
        }

        @media (max-width: 768px) {
            .two-column-grid,
            .three-column-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .container {
                margin: 1rem auto;
                padding: 0 0.5rem;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .nav-links {
                flex-wrap: wrap;
                justify-content: center;
            }

            .chart-container {
                height: 250px;
            }
        }

        /* Main Tab Navigation Styles */
        .main-tabs {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .main-tab {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            padding: 1rem 2rem;
            border-radius: 12px 12px 0 0;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #666;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .main-tab:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-3px);
        }

        .main-tab.active {
            background: rgba(255, 255, 255, 0.95);
            color: #4A90E2;
            transform: translateY(-5px);
            box-shadow: 0 4px 20px rgba(74, 144, 226, 0.2);
        }

        .main-tab i {
            font-size: 1.2rem;
        }

        /* Main Content Sections */
        .main-content {
            display: none;
        }

        .main-content.active {
            display: block;
        }

        /* Region Selector Styles */
        .region-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .region-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .region-btn:hover {
            background: #e9ecef;
        }

        .region-btn.active {
            background: #4A90E2;
            color: white;
            border-color: #4A90E2;
        }

        /* Forecast Controls Styles */
        .forecast-controls {
            display: flex;
            gap: 2rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .forecast-options {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .forecast-options label {
            font-weight: 600;
            color: #495057;
        }

        .forecast-select {
            padding: 0.5rem 1rem;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background: white;
            min-width: 150px;
        }

        .forecast-select:focus {
            outline: none;
            border-color: #4A90E2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.1);
        }

        /* Forecast Date Selector Styles */
        .forecast-date-selector {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            align-items: center;
            padding: 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border-left: 4px solid #4A90E2;
        }

        /* Model Performance Monitoring Styles */
        .config-details {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.3rem 0;
            border-bottom: 1px solid #f1f1f1;
        }

        .config-item:last-child {
            border-bottom: none;
        }

        .config-item strong {
            color: #2c3e50;
            font-weight: 600;
        }

        .config-item span {
            color: #7f8c8d;
            font-family: 'Courier New', monospace;
        }

        .performance-comparison {
            margin-top: 1.5rem;
        }

        .comparison-bars {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .comparison-item {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .comparison-label {
            min-width: 140px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .comparison-bar {
            flex: 1;
            height: 24px;
            background: #f8f9fa;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }

        .comparison-fill {
            height: 100%;
            border-radius: 12px;
            transition: width 0.8s ease;
            position: relative;
        }

        .comparison-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: 600;
            font-size: 0.8rem;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .model-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .model-config-section h4,
        .model-training-section h4 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            color: #4A90E2;
            font-size: 1.1rem;
        }

        .forecast-presets {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .forecast-presets .preset-btn {
            background: #fff;
            border: 1px solid #4A90E2;
            color: #4A90E2;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .forecast-presets .preset-btn:hover {
            background: #4A90E2;
            color: white;
        }

        .forecast-presets .preset-btn.active {
            background: #4A90E2;
            color: white;
        }

        /* Footer Styles */
        .footer {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            padding: 2rem 0;
            margin-top: 3rem;
            text-align: center;
        }

        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .copyright {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .author-info {
            color: #4A90E2;
            font-weight: 500;
            font-size: 0.95rem;
        }

        .author-info a {
            color: #4A90E2;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .author-info a:hover {
            color: #357abd;
            text-decoration: underline;
        }

        .system-info {
            color: #999;
            font-size: 0.8rem;
            margin-top: 1rem;
            border-top: 1px solid #eee;
            padding-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-svg">
                    <svg width="48" height="48" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
                        <!-- 背景圆形 -->
                        <circle cx="30" cy="30" r="28" fill="url(#sweGradient)" stroke="#2c3e50" stroke-width="2"/>
                        
                        <!-- 渐变定义 -->
                        <defs>
                            <linearGradient id="sweGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#74b9ff;stop-opacity:1" />
                                <stop offset="50%" style="stop-color:#0984e3;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#2d3436;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        
                        <!-- 主雪花 -->
                        <g transform="translate(30, 30)">
                            <!-- 水平线 -->
                            <path d="M-12 0 L12 0" stroke="#ecf0f1" stroke-width="2.5" stroke-linecap="round"/>
                            <!-- 垂直线 -->
                            <path d="M0 -12 L0 12" stroke="#ecf0f1" stroke-width="2.5" stroke-linecap="round"/>
                            <!-- 对角线 -->
                            <path d="M-8.5 -8.5 L8.5 8.5" stroke="#ecf0f1" stroke-width="2" stroke-linecap="round"/>
                            <path d="M-8.5 8.5 L8.5 -8.5" stroke="#ecf0f1" stroke-width="2" stroke-linecap="round"/>
                            
                            <!-- 雪花装饰点 -->
                            <circle cx="0" cy="0" r="1.5" fill="#74b9ff"/>
                            <circle cx="-8" cy="0" r="1" fill="#74b9ff"/>
                            <circle cx="8" cy="0" r="1" fill="#74b9ff"/>
                            <circle cx="0" cy="-8" r="1" fill="#74b9ff"/>
                            <circle cx="0" cy="8" r="1" fill="#74b9ff"/>
                        </g>
                        
                        <!-- 小雪花装饰 -->
                        <g transform="translate(15, 15)">
                            <path d="M-3 0 L3 0 M0 -3 L0 3" stroke="#74b9ff" stroke-width="1" stroke-linecap="round" opacity="0.7"/>
                        </g>
                        <g transform="translate(45, 15)">
                            <path d="M-3 0 L3 0 M0 -3 L0 3" stroke="#74b9ff" stroke-width="1" stroke-linecap="round" opacity="0.7"/>
                        </g>
                        <g transform="translate(15, 45)">
                            <path d="M-3 0 L3 0 M0 -3 L0 3" stroke="#74b9ff" stroke-width="1" stroke-linecap="round" opacity="0.7"/>
                        </g>
                        <g transform="translate(45, 45)">
                            <path d="M-3 0 L3 0 M0 -3 L0 3" stroke="#74b9ff" stroke-width="1" stroke-linecap="round" opacity="0.7"/>
                        </g>
                    </svg>
                </div>
                <div class="logo-text">
                    <h1>HydrAI-SWE <span class="subtitle-swe">Snow Water Equivalent</span></h1>
                </div>
            </div>
            <div class="nav-links">
                <a href="/hydrological-center"><i class="fas fa-chart-line"></i> Hydrological Center</a>
                <a href="/ui" class="active"><i class="fas fa-snowflake"></i> SWE (Snow Water Equivalent)</a>
                <a href="/agriculture"><i class="fas fa-leaf"></i> Agriculture</a>
                <a href="/model"><i class="fas fa-brain"></i> Model Training</a>
                <a href="/guides"><i class="fas fa-book-open"></i> User Guide</a>
                <a href="/api-docs"><i class="fas fa-code"></i> API Reference</a>
            </div>
        </div>
    </div>

    <!-- Main Navigation Tabs -->
    <div class="main-tabs">
        <button class="main-tab active" onclick="showMainTab('historical')">
            <i class="fas fa-chart-line"></i> Historical Analysis
        </button>
        <button class="main-tab" onclick="showMainTab('forecast')">
            <i class="fas fa-crystal-ball"></i> Future Forecast
        </button>
    </div>

    <div class="container">
        <!-- Historical Analysis Section -->
        <div id="historical-content" class="main-content active">
            <div class="content-grid">
                <!-- Regional Overview -->
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-map"></i>
                        <div class="card-title">Regional Snow Water Equivalent - Historical Overview</div>
                        <div class="status-indicator">
                            <div class="status-dot status-blue"></div>
                            <span>Updated Daily</span>
                        </div>
                    </div>

                    <div class="date-range-selector">
                        <div class="date-group">
                            <label>From:</label>
                            <input type="date" id="start-date" class="date-input" value="2020-01-01">
                        </div>
                        <div class="date-group">
                            <label>To:</label>
                            <input type="date" id="end-date" class="date-input" value="2024-08-20">
                        </div>
                        <div class="date-presets">
                            <button class="preset-btn" onclick="setDatePreset('1year')">Last Year</button>
                            <button class="preset-btn" onclick="setDatePreset('3years')">Last 3 Years</button>
                            <button class="preset-btn active" onclick="setDatePreset('5years')">Last 5 Years</button>
                            <button class="preset-btn" onclick="setDatePreset('all')">All Data</button>
                        </div>
                        <button class="btn" onclick="updateHistoricalChart()" style="margin-left: auto;">Update Chart</button>
                    </div>

                    <div class="chart-container" style="height: 450px; padding: 0;">
                        <canvas id="historical-chart"></canvas>
                    </div>
                </div>

                <!-- SWE Analysis Card -->
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-chart-line"></i>
                        <div class="card-title">Advanced SWE Analysis</div>
                        <div class="status-indicator">
                            <div class="status-dot status-green"></div>
                            <span>ML-Powered</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <!-- Analysis Configuration -->
                        <div class="forecast-controls">
                            <div class="forecast-options">
                                <label>Analysis Type:</label>
                                <select id="swe-analysis-mode" class="forecast-select">
                                    <option value="seasonal" selected>Seasonal Trends</option>
                                    <option value="anomaly">Anomaly Detection</option>
                                    <option value="correlation">Correlation Analysis</option>
                                    <option value="comprehensive">Comprehensive Report</option>
                                    <option value="insight-discovery">AI Insights Discovery</option>
                                </select>
                            </div>
                            <div class="forecast-options">
                                <label>Time Period:</label>
                                <select id="analysis-period-select" class="forecast-select">
                                    <option value="current-season">Current Season</option>
                                    <option value="last-year">Last Year</option>
                                    <option value="5-years" selected>Last 5 Years</option>
                                    <option value="custom">Custom Range</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Custom Date Range (hidden by default) -->
                        <div id="custom-date-range" class="date-range-selector" style="display: none;">
                            <div class="date-group">
                                <label>Start Date:</label>
                                <input type="date" id="analysis-start-date" class="date-input" value="2020-01-01">
                            </div>
                            <div class="date-group">
                                <label>End Date:</label>
                                <input type="date" id="analysis-end-date" class="date-input" value="2024-12-31">
                            </div>
                        </div>
                        
                        <!-- AI Insights Discovery Options (hidden by default) -->
                        <div id="insight-discovery-options" class="forecast-controls" style="display: none;">
                            <div class="forecast-options">
                                <label>Discovery Mode:</label>
                                <select id="insight-mode-select" class="forecast-select">
                                    <option value="anomaly">Anomaly Detection</option>
                                    <option value="clustering">Data Clustering</option>
                                    <option value="pca">Dimensionality Analysis</option>
                                    <option value="time_patterns">Time Patterns</option>
                                    <option value="swe_cold_factors">SWE Cold Factors Discovery</option>
                                    <option value="comprehensive">All Insights</option>
                                </select>
                            </div>
                            <div class="forecast-options">
                                <label>Target Variable:</label>
                                <select id="target-column-select" class="forecast-select">
                                    <option value="Snow on Grnd (cm)" selected>Snow Depth</option>
                                    <option value="snow_water_equivalent_mm">SWE</option>
                                    <option value="temperature">Temperature</option>
                                    <option value="precipitation">Precipitation</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="model-actions">
                            <button onclick="runAdvancedSWEAnalysis()" class="btn btn-primary">
                                <i class="fas fa-play"></i> Run Analysis
                            </button>
                            <button onclick="resetSWEAnalysis()" class="btn" style="background: #6c757d;">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                        
                        <div id="swe-analysis-status" class="mt-2"></div>
                        <div id="swe-analysis-results" class="mt-3"></div>
                    </div>
                </div>


                <!-- Advanced Hydrology Analysis Portal -->
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-microscope"></i>
                        <div class="card-title">Advanced Hydrology Analysis</div>
                        <div class="status-indicator">
                            <div class="status-dot status-green"></div>
                            <span>Professional Analysis Suite</span>
                        </div>
                    </div>
                    
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-8">
                                <h5><i class="fas fa-water"></i> Comprehensive Hydrology Dashboard</h5>
                                <p class="text-muted mb-3">Access the full suite of professional hydrological analysis tools including AI-powered unsupervised learning, statistical tests, clustering analysis, and expert interpretations.</p>
                                
                                <div class="analysis-features">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <ul class="feature-list">
                                                <li><i class="fas fa-chart-line text-success"></i> Time Series Decomposition</li>
                                                <li><i class="fas fa-exclamation-triangle text-warning"></i> Anomaly Detection</li>
                                                <li><i class="fas fa-sitemap text-info"></i> Clustering Analysis</li>
                                            </ul>
                                        </div>
                                        <div class="col-md-6">
                                            <ul class="feature-list">
                                                <li><i class="fas fa-chart-bar text-primary"></i> Statistical Testing</li>
                                                <li><i class="fas fa-brain text-purple"></i> Unsupervised Learning</li>
                                                <li><i class="fas fa-graduation-cap text-success"></i> Professional Interpretations</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="col-md-4 text-center">
                                <div class="analysis-portal">
                                    <button class="btn btn-primary btn-lg mb-3" onclick="openAdvancedAnalysis()">
                                        <i class="fas fa-external-link-alt"></i> Launch Analysis Suite
                                    </button>
                                    
                                    <div class="portal-features text-small">
                                        <p class="mb-2"><i class="fas fa-database"></i> Real Data Processing</p>
                                        <p class="mb-2"><i class="fas fa-robot"></i> AI-Powered Insights</p>
                                        <p class="mb-0"><i class="fas fa-microscope"></i> Expert Interpretations</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            	</div>
        	</div>

        <!-- Future Forecast Section -->
        <div id="forecast-content" class="main-content">
            <div class="content-grid">
                
                <!-- Forecast Overview -->
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-crystal-ball"></i>
                        <div class="card-title">30-Day SWE & Runoff Forecast</div>
                        <div class="status-indicator">
                            <div class="status-dot status-green"></div>
                            <span>Updated Every 6 Hours</span>
                        </div>
                    </div>
                    
                    <div class="forecast-controls">
                        <div class="forecast-options">
                            <label>Forecast Type:</label>
                            <select id="forecast-type-select" class="forecast-select">
                                <option value="swe">Snow Water Equivalent</option>
                                <option value="runoff">Runoff Volume</option>
                                <option value="combined">Combined View</option>
                            </select>
                        </div>
                        <div class="forecast-options">
                            <label>Time Range:</label>
                            <select id="forecast-range-select" class="forecast-select">
                                <option value="7">7 Days</option>
                                <option value="14">14 Days</option>
                                <option value="30" selected>30 Days</option>
                                <option value="60">60 Days</option>
                                <option value="120">4 Months</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Date Range Selector for Forecasts -->
                    <div class="forecast-date-selector">
                        <div class="date-group">
                            <label>Forecast Start Date:</label>
                            <input type="date" id="forecast-start-date" class="date-input" value="">
                        </div>
                        <div class="forecast-presets">
                            <button class="preset-btn" onclick="setForecastPreset('today')">From Today</button>
                            <button class="preset-btn" onclick="setForecastPreset('november')">From November</button>
                            <button class="preset-btn" onclick="setForecastPreset('december')">From December</button>
                            <button class="preset-btn" onclick="setForecastPreset('january')">From January</button>
                        </div>
                        <button class="btn" onclick="updateForecastChart()" style="margin-left: auto;">Update Forecast</button>
                    </div>

                    <div class="chart-container" style="height: 450px; padding: 0;">
                        <canvas id="forecast-chart"></canvas>
                    </div>
                </div>

                <!-- Risk Assessment and Runoff Predictions -->
                <div class="two-column-grid">
                    <!-- Flood Risk Assessment -->
                    <div class="card">
                        <div class="card-header">
                            <i class="fas fa-exclamation-triangle"></i>
                            <div class="card-title">Flood Risk Assessment</div>
                        </div>

                        <div class="metrics-grid" id="risk-assessment-metrics">
                            <div class="metric-item">
                                <span class="metric-value" id="risk-level-value">Loading...</span>
                                <div class="metric-label">Overall Risk Level</div>
                            </div>
                            <div class="metric-item">
                                <span class="metric-value" id="peak-risk-period-value">Loading...</span>
                                <div class="metric-label">Peak Risk Period</div>
                            </div>
                            <div class="metric-item">
                                <span class="metric-value" id="regions-at-risk-value">Loading...</span>
                                <div class="metric-label">Regions at Risk</div>
                            </div>
                            <div class="metric-item">
                                <span class="metric-value" id="alert-lead-time-value">Loading...</span>
                                <div class="metric-label">Alert Lead Time</div>
                            </div>
                        </div>

                        <div class="alert alert-warning" id="flood-alert">
                            <i class="fas fa-exclamation-triangle"></i>
                            <div id="flood-alert-content">
                                Loading flood risk assessment...
                            </div>
                        </div>
                        

                    </div>

                    <!-- Runoff Predictions -->
                    <div class="card">
                        <div class="card-header">
                            <i class="fas fa-tint"></i>
                            <div class="card-title">Runoff Predictions</div>
                        </div>

                        <div class="forecast-controls">
                            <div class="forecast-options">
                                <label>Station:</label>
                                <select id="runoff-station-select" class="forecast-select">
                                    <option value="loading">Loading stations...</option>
                                </select>
                            </div>
                        </div>

                        <div class="chart-container" style="height: 280px; padding: 0;">
                            <canvas id="runoff-chart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Regional Forecast Details -->
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-map-marked-alt"></i>
                        <div class="card-title">Regional Forecast Details</div>
                    </div>

                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Region</th>
                                <th>Current SWE</th>
                                <th>7-Day Forecast</th>
                                <th>Peak Runoff Date</th>
                                <th>Expected Volume</th>
                                <th>Risk Level</th>
                            </tr>
                        </thead>
                        <tbody id="regional-forecast-table">
                            <tr>
                                <td colspan="6" style="text-align: center; padding: 2rem;">Loading regional forecast data...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="copyright">
                © 2025 HydrAI-SWE Enhanced System. All rights reserved.
            </div>
            <div class="author-info">
                Created by <strong>Sean Li</strong> 
                (<a href="mailto:li-x55@webmail.uwinnipeg.ca">li-x55@webmail.uwinnipeg.ca</a> | 
                <a href="mailto:lixiaowww@gmail.com">lixiaowww@gmail.com</a>)
            </div>
            <div class="system-info">
                <i class="fas fa-server"></i> Snow Water Equivalent & Runoff Prediction System
                <br>
                <i class="fas fa-code"></i> Advanced Machine Learning for Hydrological Forecasting
            </div>
        </div>
    </footer>

    <script>


        // Removed fixed period mode switcher (long/medium/short). Users can select arbitrary date range via inputs or presets.

        function getSelectedStations() {
            const vals = Array.from(document.querySelectorAll('.station-checkbox'))
                .filter(cb => cb.checked)
                .map(cb => cb.value);
            // fallback: if none selected, select all available
            if (vals.length === 0) {
                return Array.from(document.querySelectorAll('.station-checkbox'))
                    .filter(cb => !cb.disabled)
                    .map(cb => cb.value);
            }
            return vals;
        }

        async function applyAvailabilityToStationSelector(startDate, endDate) {
            try {
                const avail = await fetchAvailability(startDate, endDate);
                const onlyAvail = document.getElementById('only-available-toggle')?.checked;
                const stationMap = {};
                (avail.stations || []).forEach(s => { stationMap[s.name] = s; });
                document.querySelectorAll('.station-checkbox').forEach(cb => {
                    const info = stationMap[cb.value];
                    const has = !!(info && info.has_data);
                    cb.disabled = onlyAvail ? !has : false;
                    cb.parentElement.style.opacity = (onlyAvail && !has) ? '0.5' : '1';
                    cb.title = has ? `${cb.value}` : `${cb.value} (no data in selected window)`;
                    if (onlyAvail && !has) cb.checked = false;
                });
            } catch (e) {
                console.warn('applyAvailabilityToStationSelector failed', e);
            }
        }

        // Update chart based on region selection
        async function updateRegionalChart(region) {
            console.log('Updating chart for region:', region);
            
            try {
                // Show loading notification
                showNotification('Updating chart for selected region...', 'info');
                
                // Get current date range
                const startDate = document.getElementById('start-date').value;
                const endDate = document.getElementById('end-date').value;
                
                // Reload chart with new region
                await loadHistoricalChart(startDate, endDate, region);
                
                const regionNames = {
                    'all': 'Red River Basin',
                    'southern-region': 'Southern Region',
                    'central-region': 'Central Region',
                    'western-tributary': 'Western Tributary',
                    'station-compare': 'Station Comparison'
                };
                
                showNotification(`Chart updated for ${regionNames[region] || region}`, 'success');
                
            } catch (error) {
                console.error('Failed to update regional chart:', error);
                showNotification('Failed to update chart for selected region', 'warning');
            }
        }

        // Forecast controls functionality
function initializeForecastControls() {
            const typeSel = document.getElementById('forecast-type-select');
            const rangeSel = document.getElementById('forecast-range-select');
            if (!typeSel || !rangeSel) return;
            const handler = () => {
                const type = typeSel.value || 'swe';
                const days = parseInt(rangeSel.value || '30', 10);
                // Update main forecast chart
                loadForecastChart(days, type === 'combined' ? 'swe' : type);
                // Always align runoff panel with selected horizon
                loadRunoffChart(days);
            };
            typeSel.addEventListener('change', handler);
            rangeSel.addEventListener('change', handler);
        }

        // Update forecast chart
        function updateForecastChart(type, range) {
            console.log('Updating forecast chart:', type, range);
            const chartPlaceholder = document.querySelector('#forecast-content .chart-placeholder');
            if (chartPlaceholder) {
                const typeName = type === 'swe' ? 'SWE' : 
                                type === 'runoff' ? 'RUNOFF' : 
                                'COMBINED';
                const iconClass = type === 'swe' ? 'fas fa-chart-line' :
                                 type === 'runoff' ? 'fas fa-tint' :
                                 'fas fa-chart-area';
                chartPlaceholder.innerHTML = `
                    <i class="${iconClass}"></i>
                    <div class="chart-title">${range}-Day ${typeName} Forecast</div>
                    <div class="chart-subtitle">With confidence intervals and risk alerts</div>
                `;
            }
        }

        // Auto-refresh functionality
        function refreshData() {
            // Simulate data refresh
            console.log('Refreshing real-time data...');
            
            // Add loading state
            const btn = event.target.closest('.btn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
            btn.disabled = true;
            
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                // Show success message
                showNotification('Data refreshed successfully at ' + new Date().toLocaleTimeString(), 'success');
            }, 2000);
        }

        // Update region button enabled/disabled based on availability
        async function updateRegionAvailability(startDate, endDate) {
            try {
                const avail = await fetchAvailability(startDate, endDate);
                const regions = avail.regions || {};
                document.querySelectorAll('.region-btn').forEach(btn => {
                    const key = btn.dataset.region;
                    if (!key || !regions[key]) return;
                    const has = !!regions[key].has_data;
                    btn.disabled = !has;
                    btn.style.opacity = has ? '1' : '0.5';
                    btn.title = has ? btn.title : (btn.title + ' (no data in selected window)');
                });
            } catch (e) {
                console.warn('Availability check failed', e);
            }
        }

        // Notification system
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `alert alert-${type}`;
            notification.innerHTML = `<i class="fas fa-info-circle"></i> <div>${message}</div>`;
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.zIndex = '10000';
            notification.style.minWidth = '300px';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Date preset functionality
        function setDatePreset(preset) {
            const endDate = new Date();
            let startDate = new Date();
            
            // Remove active class from all preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            switch(preset) {
                case '1year':
                    startDate.setFullYear(endDate.getFullYear() - 1);
                    break;
                case '3years':
                    startDate.setFullYear(endDate.getFullYear() - 3);
                    break;
                case '5years':
                    startDate.setFullYear(endDate.getFullYear() - 5);
                    break;
                case 'all':
                    startDate = new Date('1990-01-01');
                    break;
            }
            
            document.getElementById('start-date').value = startDate.toISOString().split('T')[0];
            document.getElementById('end-date').value = endDate.toISOString().split('T')[0];
            
            // Auto-update chart
            updateHistoricalChart();
        }
        
        // Chart instances
        let historicalChart, regionalChart, forecastChart, runoffChart;
        
        // Helper function to safely destroy charts
        function destroyChart(chartInstance) {
            if (chartInstance && typeof chartInstance.destroy === 'function') {
                try {
                    chartInstance.destroy();
                    // Unregister the chart to prevent ID conflicts
                    if (chartInstance.id !== undefined) {
                        Chart.unregister(chartInstance);
                    }
                } catch (error) {
                    console.warn('Error destroying chart:', error);
                }
                return null;
            }
            return null;
        }
        
        // Initialize charts with real data from API
        async function initializeCharts() {
            try {
                console.log('🔄 开始初始化图表...');
                
                // Show loading state
                showNotification('Loading data from API...', 'info');
                
                // Get actual date range from inputs
                const startDate = document.getElementById('start-date').value;
                const endDate = document.getElementById('end-date').value;
                console.log('📅 日期范围:', startDate, 'to', endDate);
                
                // Load Historical SWE Chart with real data (aggregate)
                console.log('📊 加载历史SWE图表...');
                await loadHistoricalChart(startDate, endDate, 'all');
                
                // Load SWE Analysis Chart (Seasonal Indices) - Disabled since replaced by Factors Discovery
                console.log('📈 SWE分析图表已替换为Factors Discovery模块');
                // await loadSweAnalysisChart(); // Disabled
                
                // Load Forecast and Runoff Charts using selected controls
                const typeSel = document.getElementById('forecast-type-select');
                const rangeSel = document.getElementById('forecast-range-select');
                const initType = typeSel ? (typeSel.value || 'swe') : 'swe';
                const initDays = parseInt(rangeSel ? (rangeSel.value || '30') : '30', 10);
                console.log('🔮 预测类型:', initType, '天数:', initDays);
                
                console.log('📊 加载预测图表...');
                await loadForecastChart(initDays, initType === 'combined' ? 'swe' : initType);
                
                console.log('🌊 加载径流图表...');
                await loadRunoffChart(initDays);
                
                console.log('✅ 所有图表加载成功');
                showNotification('All charts loaded successfully', 'success');
                
            } catch (error) {
                console.error('❌ 图表初始化失败:', error);
                showNotification('Failed to load chart data. Please try refreshing.', 'warning');
                
                // 显示详细的错误信息
                const errorDiv = document.createElement('div');
                errorDiv.className = 'alert alert-danger';
                errorDiv.innerHTML = `
                    <h4><i class="fas fa-exclamation-triangle"></i> Chart Loading Error</h4>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p><strong>Stack:</strong> ${error.stack}</p>
                    <button onclick="location.reload()" class="btn btn-sm btn-primary">Refresh Page</button>
                `;
                
                // 添加到页面顶部
                const container = document.querySelector('.container');
                if (container) {
                    container.insertBefore(errorDiv, container.firstChild);
                }
            }
        }
        
        // Show chart loading state
        function showChartLoading(chartId, message = 'Loading chart data...') {
            const canvas = document.getElementById(chartId);
            const container = canvas.parentElement;
            
            // Create loading overlay
            let loadingOverlay = container.querySelector('.chart-loading-overlay');
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'chart-loading-overlay';
                loadingOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(255, 255, 255, 0.9);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    z-index: 100;
                    border-radius: 12px;
                `;
                container.appendChild(loadingOverlay);
            }
            
            loadingOverlay.innerHTML = `
                <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: #4A90E2; margin-bottom: 1rem;"></i>
                <div style="color: #666; font-weight: 500;">${message}</div>
            `;
            loadingOverlay.style.display = 'flex';
        }
        
        // Hide chart loading state
        function hideChartLoading(chartId) {
            const canvas = document.getElementById(chartId);
            const container = canvas.parentElement;
            const loadingOverlay = container.querySelector('.chart-loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }
        
        // Validate chart data completeness
        function validateChartData(data, chartType = 'historical') {
            if (!data) {
                return { valid: false, error: 'No data received from API' };
            }
            
            if (chartType === 'historical') {
                if (!data.dates || !Array.isArray(data.dates) || data.dates.length === 0) {
                    return { valid: false, error: 'Missing or empty dates array' };
                }
                
                if (!data.swe_values || !Array.isArray(data.swe_values)) {
                    return { valid: false, error: 'Missing or invalid SWE values' };
                }
                
                if (data.dates.length !== data.swe_values.length) {
                    return { valid: false, error: 'Dates and values arrays have different lengths' };
                }
                
                // Check if we have any non-null values
                const validValues = data.swe_values.filter(v => v !== null && v !== undefined && !isNaN(v));
                if (validValues.length === 0) {
                    return { valid: false, error: 'All SWE values are null or invalid', isEmpty: true };
                }
            } else if (chartType === 'forecast') {
                if (!data.forecast_values || !Array.isArray(data.forecast_values)) {
                    return { valid: false, error: 'Missing or invalid forecast values' };
                }
                
                if (!data.dates || data.dates.length !== data.forecast_values.length) {
                    return { valid: false, error: 'Forecast dates and values mismatch' };
                }
            }
            
            return { valid: true };
        }
        
        // Create empty state chart for no data scenarios
        function createEmptyStateChart(chartId, message, suggestion = null) {
            const ctx = document.getElementById(chartId).getContext('2d');
            
            // Destroy existing chart if it exists
            const chartVar = chartId.replace('-', '') + 'Chart';
            if (window[chartVar]) {
                window[chartVar].destroy();
            }
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['No Data'],
                    datasets: [{
                        label: 'No Data Available',
                        data: [0],
                        borderColor: '#dee2e6',
                        backgroundColor: 'rgba(222, 226, 230, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: message,
                            color: '#6c757d'
                        },
                        subtitle: {
                            display: !!suggestion,
                            text: suggestion || '',
                            color: '#6c757d',
                            font: { size: 12 }
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 10,
                            display: false
                        },
                        x: {
                            display: false
                        }
                    },
                    layout: {
                        padding: 20
                    }
                }
            });
            
            // Store chart reference
            window[chartVar] = chart;
            return chart;
        }
        
        // Load historical chart with real API data
        async function loadHistoricalChart(startDate, endDate, region) {
            showChartLoading('historical-chart', 'Loading historical SWE data...');
            
            try {
                const data = await fetchHistoricalSWEData(startDate, endDate, region);
                hideChartLoading('historical-chart');
                
                // Validate data
                const validation = validateChartData(data, 'historical');
                if (!validation.valid) {
                    if (validation.isEmpty) {
                        createEmptyStateChart('historical-chart', 
                            'No SWE data available for selected period',
                            'Try expanding the date range or selecting a different region');
                        return;
                    }
                    throw new Error(validation.error);
                }
                
                const histCtx = document.getElementById('historical-chart').getContext('2d');
                
                // Safely destroy existing chart if it exists
                historicalChart = destroyChart(historicalChart);
                
                // Build datasets depending on single-series or multi-series response
                let datasets = [];
                if (Array.isArray(data.series)) {
                    // If backend returns multi-series, default to drawing them all
                    datasets = data.series.map(s => {
                        const nonNullCount = (s.values || []).filter(v => v !== null && v !== undefined && !Number.isNaN(v)).length;
                        const sparse = nonNullCount < 5;
                        return {
                            label: `${s.name} - SWE (mm)`,
                            data: s.values,
                            borderColor: s.color || '#4A90E2',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            spanGaps: !sparse,
                            showLine: !sparse,
                            pointRadius: sparse ? 3 : 1,
                            pointHoverRadius: 4,
                            fill: false,
                            tension: 0.2
                        };
                    });
                } else {
                    const nonNullCount = (data.swe_values || []).filter(v => v !== null && v !== undefined && !Number.isNaN(v)).length;
                    const sparse = nonNullCount < 5;
                    datasets = [{
                        label: `${data.region_name} - SWE (mm)`,
                        data: data.swe_values,
                        borderColor: '#4A90E2',
                        backgroundColor: 'rgba(74, 144, 226, 0.1)',
                        borderWidth: 2,
                        spanGaps: !sparse,
                        showLine: !sparse,
                        pointRadius: sparse ? 3 : 1,
                        pointHoverRadius: 4,
                        fill: !sparse,
                        tension: 0.3
                    }, {
                        label: 'Historical Average',
                        data: data.historical_average,
                        borderColor: '#27ae60',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        spanGaps: true,
                        showLine: true,
                        pointRadius: 0
                    }];
                }

                historicalChart = new Chart(histCtx, {
                    type: 'line',
                    data: {
                        labels: data.dates,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: Array.isArray(data.series) ? `Station Comparison - SWE by Station` : `Historical Snow Water Equivalent Trends - ${data.region_name}`
                            },
                            legend: {
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'SWE (mm)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to load historical chart:', error);
                if (error && error.status === 404) {
                    showNotification('No data available for this region and date range. Try expanding the date window or choosing another region.', 'info');
                    const histCtx = document.getElementById('historical-chart').getContext('2d');
                    historicalChart = destroyChart(historicalChart);
                    historicalChart = new Chart(histCtx, {
                        type: 'line',
                        data: { labels: [], datasets: [] },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { title: { display: true, text: 'No SWE data for the selected region/date range' } },
                            scales: { y: { beginAtZero: true } }
                        }
                    });
                    return; // handled gracefully
                }
                throw error;
            }
        }
        
        // Load SWE analysis chart (Seasonal Indices) - Disabled since replaced by Factors Discovery
        async function loadSweAnalysisChart() {
            try {
                // This chart has been replaced by the Factors Discovery module
                // The canvas element 'swe-analysis-chart' no longer exists
                console.log('SWE analysis chart disabled - replaced by Factors Discovery module');
                return;
            } catch (error) {
                console.error('SWE analysis chart function disabled:', error);
                return;
            }
        }
        
        // Load forecast chart with real ML model predictions
        async function loadForecastChart(days, forecastType) {
            console.log(`🔍 开始加载预测图表: ${days}天, ${forecastType}`);
            showChartLoading('forecast-chart', `Loading ${days}-day ${forecastType.toUpperCase()} forecast...`);
            
            try {
                console.log(`📡 调用预测API...`);
                const data = await fetchForecastData(days, forecastType);
                console.log(`✅ 预测API响应:`, data);
                hideChartLoading('forecast-chart');
                
                // Validate forecast data
                console.log(`🔍 验证预测数据...`);
                console.log(`📊 原始数据类型:`, {
                    dates_type: typeof data.dates,
                    values_type: typeof data.forecast_values,
                    dates_is_array: Array.isArray(data.dates),
                    values_is_array: Array.isArray(data.forecast_values)
                });
                console.log(`📊 原始数据:`, {
                    dates: data.dates,
                    forecast_values: data.forecast_values,
                    dates_length: data.dates?.length,
                    values_length: data.forecast_values?.length
                });
                const validation = validateChartData(data, 'forecast');
                console.log(`✅ 数据验证结果:`, validation);
                if (!validation.valid) {
                    console.error(`❌ 预测数据验证失败:`, validation.error);
                    createEmptyStateChart('forecast-chart', 
                        'Forecast data unavailable',
                        `Unable to generate ${forecastType} forecast for ${days} days`);
                    return;
                }
                const conf = (typeof data.confidence_level === 'number' ? data.confidence_level : 90);
                
                const forecastCtx = document.getElementById('forecast-chart').getContext('2d');
                
                // Safely destroy existing chart if it exists
                forecastChart = destroyChart(forecastChart);
                
                // Check if all values are zero (no snow season)
                const allZero = data.forecast_values.every(val => val === 0);
                
                // Check if we have real forecast data (not all zeros)
                const hasRealData = data.forecast_values.some(val => val !== 0);
                
                if (allZero && forecastType === 'swe') {
                    // Create a special chart showing seasonal information for current summer
                    forecastChart = new Chart(forecastCtx, {
                        type: 'line',
                        data: {
                            labels: data.dates,
                            datasets: [{
                                label: 'Current Summer Season (No Snow)',
                                data: data.forecast_values,
                                borderColor: '#ffc107',
                                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Current Period - No Snow Expected'
                                },
                                subtitle: {
                                    display: true,
                                    text: 'Select a winter date (Nov-Mar) to see snow forecasts'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 50,
                                    title: {
                                        display: true,
                                        text: data.y_axis_label
                                    }
                                }
                            }
                        }
                    });
                    return;
                }
                
                // Create normal forecast chart with real data
                forecastChart = new Chart(forecastCtx, {
                    type: 'line',
                    data: {
                        labels: data.dates,
                        datasets: [{
                            label: `${data.forecast_type} Forecast`,
                            data: data.forecast_values,
                            borderColor: '#4A90E2',
                            backgroundColor: 'rgba(74, 144, 226, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${days}-Day ${data.forecast_type} Forecast from ${new Date().toLocaleDateString()}`
                            },
                            subtitle: {
                                display: true,
                                text: `Model: ${data.model_version} | Confidence: ${data.confidence_level}%`
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false, // Allow negative values for SWE
                                title: {
                                    display: true,
                                    text: data.y_axis_label
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to load forecast chart:', error);
                throw error;
            }
        }
        
        // Load runoff chart with real ML model predictions
        async function loadRunoffChart(days, stationId = '05OC011') {
            showChartLoading('runoff-chart', `Loading ${days}-day runoff forecast...`);
            
            const runoffCtx = document.getElementById('runoff-chart').getContext('2d');
            
            // Safely destroy existing chart if it exists
            runoffChart = destroyChart(runoffChart);
            
            try {
                const data = await fetchRunoffPredictions(days, stationId);
                hideChartLoading('runoff-chart');
                
                // Check if we have valid data with the expected format
                if (data && data.forecasts && Array.isArray(data.forecasts) && data.forecasts.length > 0) {
                    // API returns {station_id, forecasts: [{date, streamflow_m3s}]}
                    const dates = data.forecasts.map(f => f.date);
                    const flowRates = data.forecasts.map(f => f.streamflow_m3s);
                
                runoffChart = new Chart(runoffCtx, {
                    type: 'line',
                    data: {
                            labels: dates,
                            datasets: [{
                                label: `Station ${data.station_id} (API Data)`,
                                data: flowRates,
                                borderColor: '#3498db',
                                backgroundColor: 'rgba(52, 152, 219, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                    text: `${days}-Day Runoff Forecast - Station ${data.station_id}`
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Flow Rate (m³/s)'
                                }
                            }
                        }
                    }
                });
                    
                    console.log('Runoff chart loaded with API data');
                    return; // Successfully loaded API data, exit function
                }
                
                // If we reach here, API data format is not as expected
                console.warn('API data format not as expected, using simulated data');
                throw new Error('API data format mismatch - using simulation');
                
            } catch (error) {
                console.warn('API runoff data not available, using simulated data:', error);
                hideChartLoading('runoff-chart');
                
                // No simulated data allowed - show error message
                displayDiv.innerHTML = `
                    <div class="alert alert-warning">
                        <h4><i class="fas fa-exclamation-triangle"></i> Data Not Available</h4>
                        <p>Runoff data is not available at this time. Please try again later or contact the administrator.</p>
                        <p><strong>Error:</strong> ${error.message}</p>
                    </div>
                `;
                return;
                
                // No simulated data allowed
                
                runoffChart = new Chart(runoffCtx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: simulatedDatasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${days}-Day Runoff Forecast (Simulated Data)`
                            },
                            subtitle: {
                                display: true,
                                text: 'Real-time API data unavailable - showing seasonal patterns'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Flow Rate (m³/s)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // ========================================
        // REAL DATA API FUNCTIONS
        // ========================================
        
        // API Configuration - Unified path structure
        const API_BASE_URL = '';
        const API_FLOOD_URL = '/api/v1/flood'; // 洪水模块使用独立路径
        const API_AGRICULTURE_URL = '/api/v1/agriculture'; // 农业模块使用独立路径
        const API_TIMEOUT = 30000; // 30 seconds
        const MAX_RETRIES = 3;
        
        // Generic API fetch with error handling and retry mechanism
        async function apiRequest(endpoint, options = {}, baseUrl = API_BASE_URL) {
            let lastError;
            
            for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT);
                
                try {
                    const response = await fetch(`${baseUrl}${endpoint}`, {
                        ...options,
                        signal: controller.signal,
                        headers: {
                            'Content-Type': 'application/json',
                            ...options.headers
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        const err = new Error(`HTTP ${response.status}: ${errorText}`);
                        err.status = response.status;
                        throw err;
                    }
                    
                    return await response.json();
                } catch (error) {
                    clearTimeout(timeoutId);
                    lastError = error;
                    
                    // Don't retry on client errors (4xx)
                    if (error.status >= 400 && error.status < 500) {
                        break;
                    }
                    
                    // Show retry notification (except on last attempt)
                    if (attempt < MAX_RETRIES) {
                        console.warn(`API request failed (attempt ${attempt}/${MAX_RETRIES}) for ${endpoint}:`, error);
                        showNotification(`Retrying request... (${attempt}/${MAX_RETRIES})`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
                    }
                }
            }
            
            console.error(`API request failed after ${MAX_RETRIES} attempts for ${endpoint}:`, lastError);
            showNotification(`Failed to load data from ${endpoint}. Please try again later.`, 'error');
            throw lastError;
        }
        
        // Fetch historical SWE data from backend
        async function fetchHistoricalSWEData(startDate, endDate, region) {
            const params = new URLSearchParams({
                start_date: startDate,
                end_date: endDate,
                region: region
            });
            
            return await apiRequest(`/api/swe/historical?${params}`);
        }
        
        // Fetch availability counts for stations/regions
        async function fetchAvailability(startDate, endDate) {
            const params = new URLSearchParams({ start_date: startDate, end_date: endDate });
            return await apiRequest(`/api/swe/availability?${params}`);
        }
        
        // Fetch forecast data from ML model
        async function fetchForecastData(days, forecastType, region = 'all') {
            const params = new URLSearchParams({
                days: days,
                forecast_type: forecastType,
                region: region
            });
            
            return await apiRequest(`/api/swe/forecast?${params}`);
        }
        
        // Fetch current season summary metrics
        async function fetchCurrentSeasonSummary() {
            return await apiRequest('/api/swe/current-season-summary');
        }
        
        // Fetch regional trends data
        async function fetchRegionalTrends() {
            return await apiRequest('/api/swe/regional-trends');
        }
        
        // Fetch flood risk assessment
        async function fetchFloodRiskAssessment() {
            return await apiRequest('/api/v1/flood/risk-assessment');
        }
        
        // Fetch runoff predictions
        async function fetchRunoffPredictions(days = 14, stationId = '05OC011') {
            // Backend currently requires station_id; default to Red River at Winnipeg (05OC011)
            const params = new URLSearchParams({ days: days, station_id: stationId });
            return await apiRequest(`/api/swe/runoff-forecast?${params}`);
        }
        
        // Fetch available stations for runoff forecasting
        async function fetchAvailableStations() {
            return await apiRequest('/api/swe/stations/real-time');
        }
        
        // Fetch regional forecast details
        async function fetchRegionalForecastDetails() {
            return await apiRequest('/api/swe/regional-forecast');
        }
        
        // Run SWE analysis via backend module
        async function fetchSweAnalysis(mode, dataPath=null, column='snow_water_equivalent_mm') {
            return await apiRequest('/api/swe/analysis', {
                method: 'POST',
                body: JSON.stringify({
                    mode: mode,
                    data_path: dataPath,
                    column: column
                })
            });
        }
        
        // ========================================
        // NEW API FUNCTIONS FOR ENHANCED MODELS
        // ========================================
        
        // Fetch ensemble model performance metrics
        async function fetchEnsembleModelPerformance() {
            return await apiRequest('/api/swe/model-performance');
        }
        
        // Run unsupervised insight discovery analysis
        async function fetchInsightDiscovery(mode = 'anomaly', dataPath = null, targetColumn = 'Snow on Grnd (cm)') {
            return await apiRequest('/api/swe/insight-discovery', {
                method: 'POST',
                body: JSON.stringify({
                    mode: mode,
                    data_path: dataPath,
                    target_column: targetColumn
                })
            });
        }
        
        // Fetch runoff forecast with enhanced ensemble model
        async function fetchEnhancedRunoffForecast(stationId, startDate, endDate, mode = 'nowcast') {
            const params = new URLSearchParams({
                station_id: stationId,
                end_date: endDate,
                mode: mode
            });
            return await apiRequest(`/api/swe/runoff-forecast?${params}`);
        }
        
        function renderSweAnalysisResult(payload) {
            const box = document.getElementById('swe-analysis-results');
            const status = document.getElementById('swe-analysis-status');
            if (!box) return;
            status.textContent = '';
            try {
                if (!payload || !payload.result) {
                    box.className = 'alert alert-warning';
                    box.innerHTML = '<i class="fas fa-exclamation-triangle"></i><div>No analysis result.</div>';
                    return;
                }
                const mode = payload.mode;
                const r = payload.result;
                box.className = 'alert alert-info';
                if (mode === 'seasonal') {
                    const trend = r.annual_cycle?.trend || {};
                    const tpdec = (trend.trend_per_decade !== undefined && trend.trend_per_decade !== null) ? 
                        Number(trend.trend_per_decade).toFixed(3) : 'n/a';
                    const p = (trend.p_value !== undefined && trend.p_value !== null) ? 
                        Number(trend.p_value).toExponential(2) : 'n/a';
                    const mp = (r.frequency_analysis?.main_period !== undefined && 
                        r.frequency_analysis?.main_period !== null && 
                        !isNaN(r.frequency_analysis.main_period) && 
                        isFinite(r.frequency_analysis.main_period)) ? 
                        Number(r.frequency_analysis.main_period).toFixed(1) : 'n/a';
                    
                    // Get seasonal indices for peak month determination
                    const seasonalIndices = r.monthly_patterns?.seasonal_indices || [];
                    let peakMonth = 'n/a';
                    if (seasonalIndices.length >= 12) {
                        const validIndices = seasonalIndices.filter(x => x !== null && !isNaN(x));
                        if (validIndices.length > 0) {
                            const maxIndex = seasonalIndices.indexOf(Math.max(...validIndices));
                            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                            peakMonth = monthNames[maxIndex] || 'n/a';
                        }
                    }
                    
                    box.innerHTML = `<i class="fas fa-chart-line"></i><div>
                        <strong>Trend per decade:</strong> ${tpdec} mm/decade | 
                        <strong>p-value:</strong> ${p} | 
                        <strong>Peak SWE month:</strong> ${peakMonth} | 
                        <strong>Dominant period:</strong> ${mp} days
                    </div>`;
                } else if (mode === 'anomaly') {
                    // Safely extract anomaly detection results
                    const threshold = (r.threshold !== undefined && r.threshold !== null) ? 
                        Number(r.threshold).toFixed(2) : 'n/a';
                    const anomalyRate = (r.anomaly_rate !== undefined && r.anomaly_rate !== null) ? 
                        (Number(r.anomaly_rate) * 100).toFixed(1) + '%' : 'n/a';
                    
                    // Get anomaly counts by method if available
                    let methodBreakdown = '';
                    if (r.anomaly_counts) {
                        const counts = r.anomaly_counts;
                        const statistical = counts.statistical_anomalies || 0;
                        const ml = counts.ml_anomalies || 0;
                        const ts = counts.timeseries_anomalies || 0;
                        methodBreakdown = ` | Statistical: ${statistical}, ML: ${ml}, Time Series: ${ts}`;
                    }
                    
                    box.innerHTML = `<i class="fas fa-bell"></i><div>
                        <strong>Anomaly threshold:</strong> ${threshold} | 
                        <strong>Detection rate:</strong> ${anomalyRate}${methodBreakdown}
                    </div>`;
                } else if (mode === 'correlation') {
                    // Safely parse correlation analysis results
                    let correlationText = 'No significant correlations found';
                    if (r.top_correlations && Array.isArray(r.top_correlations) && r.top_correlations.length > 0) {
                        const validCorrelations = r.top_correlations.filter(x => 
                            x && x.variable && x.pearson_r !== undefined && x.pearson_r !== null && 
                            x.pearson_p !== undefined && x.pearson_p !== null
                        ).slice(0, 5);
                        
                        if (validCorrelations.length > 0) {
                            correlationText = validCorrelations.map(x => 
                                `${x.variable}: r=${Number(x.pearson_r).toFixed(3)} (p=${Number(x.pearson_p).toExponential(2)})`
                            ).join('<br/>');
                        }
                    }
                    
                    // Get correlation summary stats if available
                    let summaryStats = '';
                    if (r.correlation_summary) {
                        const cs = r.correlation_summary;
                        const avgR = (cs.average_correlation !== undefined && cs.average_correlation !== null) ? 
                            Number(cs.average_correlation).toFixed(3) : 'n/a';
                        const strongCount = cs.strong_correlations_count || 0;
                        summaryStats = ` | Avg correlation: ${avgR}, Strong correlations: ${strongCount}`;
                    }
                    
                    box.innerHTML = `<i class="fas fa-project-diagram"></i><div>
                        <strong>Top correlations (Pearson):</strong><br/>${correlationText}${summaryStats}
                    </div>`;
                } else {
                    // Handle comprehensive or unknown modes
                    const summary = (r.summary !== undefined && r.summary !== null) ? 
                        String(r.summary) : 'Completed comprehensive analysis.';
                    box.innerHTML = `<i class="fas fa-layer-group"></i><div>${summary}</div>`;
                }
            } catch (e) {
                box.className = 'alert alert-warning';
                box.innerHTML = `<i class="fas fa-exclamation-triangle"></i><div>Failed to render analysis result.</div>`;
            }
        }
        
        async function runSweAnalysisFromUI() {
            const modeSel = document.getElementById('swe-analysis-mode');
            const mode = modeSel ? modeSel.value : 'seasonal';
            const status = document.getElementById('swe-analysis-status');
            const box = document.getElementById('swe-analysis-results');
            if (status) status.textContent = 'Running analysis...';
            if (box) { box.className = 'alert alert-info'; box.innerHTML = '<i class="fas fa-spinner fa-spin"></i><div>Processing...</div>'; }
            try {
                const res = await fetchSweAnalysis(mode, null, 'snow_water_equivalent_mm');
                renderSweAnalysisResult(res);
                if (status) status.textContent = 'Done';
            } catch (e) {
                if (box) { box.className = 'alert alert-warning'; box.innerHTML = '<i class="fas fa-exclamation-triangle"></i><div>Analysis failed.</div>'; }
                if (status) status.textContent = 'Failed';
                console.error('SWE analysis failed', e);
            }
        }
        
        
        // Update historical chart based on date range and region
        async function updateHistoricalChart() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            if (!startDate || !endDate) {
                const message = translations[currentLanguage].validation.selectDateRange;
                showNotification(message, 'warning');
                return;
            }
            
            const startYear = new Date(startDate).getFullYear();
            const endYear = new Date(endDate).getFullYear();
            
            if (startYear > endYear) {
                const message = translations[currentLanguage].validation.startDateError;
                showNotification(message, 'warning');
                return;
            }
            
            try {
                // Show loading notification
                showNotification('Updating chart data...', 'info');
                
                // Reload the chart using aggregate region
                await loadHistoricalChart(startDate, endDate, 'all');
                
                // Update preset button states
                updateDatePresetStates(startYear, endYear);
                
                showNotification(`Chart updated (${startDate} to ${endDate})`, 'success');
                
            } catch (error) {
                console.error('Failed to update historical chart:', error);
                showNotification('Failed to update chart. Please try again.', 'warning');
            }
        }
        
        // Update date preset button states based on current date range
        function updateDatePresetStates(startYear, endYear) {
            const currentYear = new Date().getFullYear();
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            
            if (startYear === currentYear - 1 && endYear === currentYear) {
                document.querySelector('[onclick="setDatePreset(\'1year\')"]').classList.add('active');
            } else if (startYear === currentYear - 3 && endYear === currentYear) {
                document.querySelector('[onclick="setDatePreset(\'3years\')"]').classList.add('active');
            } else if (startYear === currentYear - 5 && endYear === currentYear) {
                document.querySelector('[onclick="setDatePreset(\'5years\')"]').classList.add('active');
            } else if (startYear === 1990) {
                document.querySelector('[onclick="setDatePreset(\'all\')"]').classList.add('active');
            }
        }
        
        // Initialize runoff station dropdown
        async function initializeRunoffStations() {
            try {
                const stationSelect = document.getElementById('runoff-station-select');
                if (!stationSelect) return;
                
                const stationsData = await fetchAvailableStations();
                
                // Clear loading placeholder
                stationSelect.innerHTML = '';
                
                // Populate dropdown with available stations
                if (stationsData.stations && stationsData.stations.length > 0) {
                    stationsData.stations.forEach(station => {
                        const option = document.createElement('option');
                        option.value = station.station_id;
                        option.textContent = `${station.name} (${station.station_id})`;
                        
                        // Set default selection to 05OC011 if it exists
                        if (station.station_id === '05OC011') {
                            option.selected = true;
                        }
                        
                        stationSelect.appendChild(option);
                    });
                } else {
                    // Fallback if no stations are returned
                    const option = document.createElement('option');
                    option.value = '05OC011';
                    option.textContent = 'Red River at Winnipeg (05OC011)';
                    option.selected = true;
                    stationSelect.appendChild(option);
                }
                
                // Add change event listener to update runoff chart when station changes
                stationSelect.addEventListener('change', async function() {
                    const selectedStation = this.value;
                    const rangeSel = document.getElementById('forecast-range-select');
                    const days = parseInt(rangeSel ? (rangeSel.value || '30') : '30', 10);
                    
                    showNotification(`Loading runoff forecast for station ${selectedStation}...`, 'info');
                    
                    try {
                        await loadRunoffChart(days, selectedStation);
                        showNotification(`Runoff forecast updated for station ${selectedStation}`, 'success');
                    } catch (error) {
                        console.error('Failed to update runoff chart:', error);
                        showNotification('Failed to load runoff forecast for selected station', 'warning');
                    }
                });
                
            } catch (error) {
                console.error('Failed to initialize runoff stations:', error);
                // Set fallback option
                const stationSelect = document.getElementById('runoff-station-select');
                if (stationSelect) {
                    stationSelect.innerHTML = '<option value="05OC011">Red River at Winnipeg (05OC011)</option>';
                }
            }
        }
        
        // Note: DOMContentLoaded initialization moved to main event listener below

        // Forecast date preset functionality
        function setForecastPreset(preset) {
            const today = new Date();
            let forecastDate = new Date();
            
            // Remove active class from all forecast preset buttons
            document.querySelectorAll('.forecast-presets .preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const currentYear = today.getFullYear();
            const nextYear = currentYear + 1;
            
            switch(preset) {
                case 'today':
                    forecastDate = today;
                    break;
                case 'november':
                    // Use November 1st of current year, or next year if we're past November
                    if (today.getMonth() >= 11) { // December = 11
                        forecastDate = new Date(nextYear, 10, 1); // November = 10
                    } else {
                        forecastDate = new Date(currentYear, 10, 1);
                    }
                    break;
                case 'december':
                    // Use December 1st of current year, or next year if we're past December
                    if (today.getMonth() === 11 && today.getDate() > 15) { // If it's past mid December
                        forecastDate = new Date(nextYear, 11, 1);
                    } else {
                        forecastDate = new Date(currentYear, 11, 1);
                    }
                    break;
                case 'january':
                    // Use January 1st of next year
                    forecastDate = new Date(nextYear, 0, 1);
                    break;
            }
            
            document.getElementById('forecast-start-date').value = forecastDate.toISOString().split('T')[0];
            
            // Automatically update the forecast after setting the date
            setTimeout(() => {
                updateForecastChart();
            }, 100);
        }

        // Initialize forecast date
        function initializeForecastDate() {
            const forecastDateInput = document.getElementById('forecast-start-date');
            if (forecastDateInput && !forecastDateInput.value) {
                const today = new Date();
                forecastDateInput.value = today.toISOString().split('T')[0];
            }
        }

        // Update forecast chart with custom date
        function updateForecastChart() {
            const forecastStartDate = document.getElementById('forecast-start-date').value;
            const typeSel = document.getElementById('forecast-type-select');
            const rangeSel = document.getElementById('forecast-range-select');
            
            if (!forecastStartDate) {
                showNotification('Please select a forecast start date', 'warning');
                return;
            }
            
            const selectedDate = new Date(forecastStartDate);
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Reset time for comparison
            selectedDate.setHours(0, 0, 0, 0);
            
            if (selectedDate < today) {
                showNotification('Forecast start date cannot be in the past. Please select today or a future date.', 'warning');
                return;
            }
            
            try {
                showNotification('Updating forecast for selected date...', 'info');
                
                const type = typeSel ? (typeSel.value || 'swe') : 'swe';
                const days = parseInt(rangeSel ? (rangeSel.value || '30') : '30', 10);
                
                // For now, we'll use the standard API but this could be enhanced to accept start_date parameter
                loadForecastChartWithDate(days, type === 'combined' ? 'swe' : type, forecastStartDate);
                loadRunoffChart(days);
                
                const dateStr = selectedDate.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                showNotification(`Forecast updated starting from ${dateStr}`, 'success');
                
            } catch (error) {
                console.error('Failed to update forecast:', error);
                showNotification('Failed to update forecast. Please try again.', 'warning');
            }
        }

        // Load forecast chart with custom start date
        async function loadForecastChartWithDate(days, forecastType, startDate = null) {
            try {
                // If no start date provided, use the regular API
                let data;
                if (!startDate || startDate === new Date().toISOString().split('T')[0]) {
                    data = await fetchForecastData(days, forecastType);
                } else {
                    // For custom dates, we'll need to simulate future forecasting
                    // This is a placeholder - in a real system, you'd modify the API to accept start_date
                    const selectedDate = new Date(startDate);
                    const today = new Date();
                    const daysDifference = Math.ceil((selectedDate - today) / (1000 * 60 * 60 * 24));
                    
                    // Generate dates starting from the selected date
                    const forecastDates = [];
                    for (let i = 0; i < days; i++) {
                        const date = new Date(selectedDate);
                        date.setDate(date.getDate() + i);
                        forecastDates.push(date.toISOString().split('T')[0]);
                    }
                    
                    // Simulate forecast data - in winter months, show increasing SWE values
                    const forecastValues = [];
                    const upperConfidence = [];
                    const lowerConfidence = [];
                    
                    const startMonth = selectedDate.getMonth();
                    const isWinterSeason = startMonth >= 10 || startMonth <= 3; // Nov-Mar
                    
                    for (let i = 0; i < days; i++) {
                        let baseValue = 0;
                        if (isWinterSeason && forecastType === 'swe') {
                            // Simulate snow accumulation during winter
                            baseValue = Math.max(0, 20 + (i * 2.5) + Math.random() * 10 - 5);
                            if (startMonth === 0 || startMonth === 1) { // Jan-Feb
                                baseValue *= 1.5; // Peak season
                            }
                        } else if (forecastType === 'runoff') {
                            // Simulate runoff - higher in spring
                            if (startMonth >= 2 && startMonth <= 5) { // Mar-May
                                baseValue = 50 + (i * 1.2) + Math.random() * 20;
                            } else {
                                baseValue = Math.max(0, 10 + Math.random() * 5);
                            }
                        }
                        
                        forecastValues.push(baseValue);
                        upperConfidence.push(baseValue * 1.3);
                        lowerConfidence.push(Math.max(0, baseValue * 0.7));
                    }
                    
                    data = {
                        dates: forecastDates,
                        forecast_values: forecastValues,
                        upper_confidence: upperConfidence,
                        lower_confidence: lowerConfidence,
                        forecast_type: forecastType.toUpperCase(),
                        y_axis_label: forecastType === 'swe' ? 'SWE (mm)' : 'Runoff (m³/s)',
                        model_version: 'simulated-future-v1',
                        confidence_level: 90
                    };
                }
                
                const conf = (typeof data.confidence_level === 'number' ? data.confidence_level : 90);
                const forecastCtx = document.getElementById('forecast-chart').getContext('2d');
                
                // Safely destroy existing chart if it exists
                forecastChart = destroyChart(forecastChart);
                
                // Check if all values are zero (summer season from today)
                const allZero = data.forecast_values.every(val => val === 0);
                
                if (allZero && forecastType === 'swe' && (!startDate || startDate === new Date().toISOString().split('T')[0])) {
                    // Create a special chart showing seasonal information for current summer
                    forecastChart = new Chart(forecastCtx, {
                        type: 'line',
                        data: {
                            labels: data.dates,
                            datasets: [{
                                label: 'Current Summer Season (No Snow)',
                                data: data.forecast_values,
                                borderColor: '#ffc107',
                                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Current Period - No Snow Expected'
                                },
                                subtitle: {
                                    display: true,
                                    text: 'Select a winter date (Nov-Mar) to see snow forecasts'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 50,
                                    title: {
                                        display: true,
                                        text: data.y_axis_label
                                    }
                                }
                            }
                        }
                    });
                    return;
                }
                
                // Create normal forecast chart
                forecastChart = new Chart(forecastCtx, {
                    type: 'line',
                    data: {
                        labels: data.dates,
                        datasets: [{
                            label: `${data.forecast_type} Forecast`,
                            data: data.forecast_values,
                            borderColor: '#4A90E2',
                            backgroundColor: 'rgba(74, 144, 226, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${days}-Day ${data.forecast_type} Forecast`
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: data.y_axis_label
                                }
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Failed to load forecast chart with date:', error);
                // Fall back to regular forecast chart
                loadForecastChart(days, forecastType);
            }
        }

        // Auto-refresh every 5 minutes
        setInterval(() => {
            console.log('Auto-refreshing data...');
            // In a real application, this would fetch fresh data from the API
        }, 300000);
        
        // Language translation data
        const translations = {
            en: {
                title: 'HydrAI-SWE Enhanced System - Snow Water Equivalent & Runoff Prediction',
                subtitle: 'Enhanced System',
                nav: {
                    dashboard: 'Dashboard',
                    applications: 'Applications',
                    modelTraining: 'Model Training',
                    userGuide: 'User Guide',
                    apiReference: 'API Reference'
                },
                tabs: {
                    historical: 'Historical Analysis',
                    forecast: 'Future Forecast'
                },
                historicalSection: {
                    title: 'Regional Snow Water Equivalent - Historical Overview',
                    status: 'Updated Daily',
                    regions: {
                        all: 'All Regions',
                        alberta: 'Alberta',
                        bc: 'British Columbia',
                        manitoba: 'Manitoba',
                        saskatchewan: 'Saskatchewan'
                    },
                    dateLabels: {
                        from: 'From:',
                        to: 'To:',
                        lastYear: 'Last Year',
                        last3Years: 'Last 3 Years',
                        last5Years: 'Last 5 Years',
                        allData: 'All Data',
                        updateChart: 'Update Chart'
                    },
                    currentSeason: {
                        title: 'Current Season Summary',
                        totalSnow: 'Total Snow Accumulation',
                        vsHistorical: 'vs. Historical Average',
                        peakDate: 'Peak SWE Date',
                        activeStations: 'Active Stations',
                        status: 'Season Status:',
                        statusText: 'Above-average snowpack across most regions. Peak accumulation recorded in mid-March.',
                        dataSources: 'Data Sources:',
                        dataSourcesText: 'Real-time data from Environment Canada, Provincial Water Survey Networks, USGS Cross-Border Monitoring Stations, and Automated Snow Pillow Networks.'
                    },
                    regionalTrends: 'SWE Seasonal Indices (baseline 1991–2020)',
                    majorBasins: 'Major Basin Analysis'
                },
                forecastSection: {
                    title: '30-Day SWE & Runoff Forecast',
                    status: 'Updated Every 6 Hours',
                    forecastType: 'Forecast Type:',
                    timeRange: 'Time Range:',
                    swe: 'Snow Water Equivalent',
                    runoff: 'Runoff Volume',
                    combined: 'Combined View',
                    days7: '7 Days',
                    days14: '14 Days',
                    days30: '30 Days',
                    days60: '60 Days',
                    days120: '4 Months',
                    forecastStartDate: 'Forecast Start Date:',
                    fromToday: 'From Today',
                    fromNovember: 'From November',
                    fromDecember: 'From December',
                    fromJanuary: 'From January',
                    updateForecast: 'Update Forecast'
                },
                sweAnalysis: {
                    title: 'Advanced SWE Analysis',
                    status: 'ML-Powered',
                    analysisType: 'Analysis Type:',
                    timePeriod: 'Time Period:',
                    seasonalTrends: 'Seasonal Trends',
                    anomalyDetection: 'Anomaly Detection',
                    correlationAnalysis: 'Correlation Analysis',
                    comprehensiveReport: 'Comprehensive Report',
                    aiInsightsDiscovery: 'AI Insights Discovery',
                    currentSeason: 'Current Season',
                    lastYear: 'Last Year',
                    last5Years: 'Last 5 Years',
                    customRange: 'Custom Range',
                    startDate: 'Start Date:',
                    endDate: 'End Date:',
                    discoveryMode: 'Discovery Mode:',
                    targetVariable: 'Target Variable:',
                    runAnalysis: 'Run Analysis',
                    reset: 'Reset'
                },
                floodWarning: {
                    title: 'Flood Warning System',
                    region: 'Region:',
                    predictionDays: 'Prediction Days:',
                    redRiverBasin: 'Red River Basin',
                    winnipegMetro: 'Winnipeg Metro',
                    manitobaProvince: 'Manitoba Province',
                    assessFloodRisk: 'Assess Flood Risk',
                    realTimeRisk: 'Real-time Risk'
                },
                riskAssessment: {
                    title: 'Flood Risk Assessment',
                    overallRiskLevel: 'Overall Risk Level',
                    peakRiskPeriod: 'Peak Risk Period',
                    regionsAtRisk: 'Regions at Risk',
                    alertLeadTime: 'Alert Lead Time',
                    loadingAssessment: 'Loading flood risk assessment...'
                },
                runoffPredictions: {
                    title: 'Runoff Predictions',
                    station: 'Station:',
                    loadingStations: 'Loading stations...'
                },
                regionalForecast: {
                    title: 'Regional Forecast Details',
                    region: 'Region',
                    currentSwe: 'Current SWE',
                    sevenDayForecast: '7-Day Forecast',
                    peakRunoffDate: 'Peak Runoff Date',
                    expectedVolume: 'Expected Volume',
                    riskLevel: 'Risk Level',
                    loadingData: 'Loading regional forecast data...'
                },
                footer: {
                    copyright: '© 2025 HydrAI-SWE Enhanced System. All rights reserved.',
                    createdBy: 'Created by',
                    systemInfo: 'Snow Water Equivalent & Runoff Prediction System',
                    systemDescription: 'Advanced Machine Learning for Hydrological Forecasting'
                },
                welcome: 'Welcome to HydrAI-SWE Enhanced System',
                validation: {
                    selectDateRange: 'Please select a valid date range',
                    startDateError: 'Start date cannot be later than end date'
                },
                notifications: {
                    chartUpdated: 'Chart updated for {region} ({startDate} to {endDate})',
                    loadingData: 'Loading data from API...',
                    chartsLoaded: 'All charts loaded successfully',
                    updatingChart: 'Updating chart data...',
                    analysisComplete: 'Analysis completed successfully',
                    analysisFailed: 'Analysis failed'
                }
            },
            fr: {
                title: 'Système HydrAI-SWE Amélioré - Équivalent en Eau de Neige et Prédiction du Ruissellement',
                subtitle: 'Système Amélioré',
                nav: {
                    dashboard: 'Tableau de Bord',
                    applications: 'Applications',
                    modelTraining: 'Formation du Modèle',
                    userGuide: 'Guide Utilisateur',
                    apiReference: 'Référence API'
                },
                tabs: {
                    historical: 'Analyse Historique',
                    forecast: 'Prévisions Futures'
                },
                historicalSection: {
                    title: 'Équivalent en Eau de Neige Régional - Vue d\'ensemble Historique',
                    status: 'Mis à jour quotidiennement',
                    regions: {
                        all: 'Toutes les Régions',
                        alberta: 'Alberta',
                        bc: 'Colombie-Britannique',
                        manitoba: 'Manitoba',
                        saskatchewan: 'Saskatchewan'
                    },
                    dateLabels: {
                        from: 'De:',
                        to: 'À:',
                        lastYear: 'Dernière Année',
                        last3Years: '3 Dernières Années',
                        last5Years: '5 Dernières Années',
                        allData: 'Toutes Données',
                        updateChart: 'Mettre à Jour'
                    },
                    currentSeason: {
                        title: 'Résumé de la Saison Actuelle',
                        totalSnow: 'Accumulation Totale de Neige',
                        vsHistorical: 'vs Moyenne Historique',
                        peakDate: 'Date de Pic EEN',
                        activeStations: 'Stations Actives',
                        status: 'Statut de la Saison:',
                        statusText: 'Manteau neigeux supérieur à la moyenne dans la plupart des régions. Accumulation maximale enregistrée mi-mars.',
                        dataSources: 'Sources de Données:',
                        dataSourcesText: 'Données en temps réel d\'Environnement Canada, des Réseaux Provinciaux d\'Enquête sur l\'Eau, des Stations de Surveillance Transfrontalières USGS et des Réseaux Automatisés de Coussins de Neige.'
                    },
                    regionalTrends: 'Indices Saisonniers EEN (référence 1991–2020)',
                    majorBasins: 'Analyse des Bassins Principaux'
                },
                forecastSection: {
                    title: 'Prévisions EEN et Ruissellement sur 30 Jours',
                    status: 'Mis à jour toutes les 6 heures',
                    forecastType: 'Type de Prévision:',
                    timeRange: 'Plage Temporelle:',
                    swe: 'Équivalent en Eau de Neige',
                    runoff: 'Volume de Ruissellement',
                    combined: 'Vue Combinée',
                    days7: '7 Jours',
                    days14: '14 Jours',
                    days30: '30 Jours',
                    days60: '60 Jours',
                    days120: '4 Mois',
                    forecastStartDate: 'Date de Début de Prévision:',
                    fromToday: 'À partir d\'Aujourd\'hui',
                    fromNovember: 'À partir de Novembre',
                    fromDecember: 'À partir de Décembre',
                    fromJanuary: 'À partir de Janvier',
                    updateForecast: 'Mettre à Jour les Prévisions'
                },
                sweAnalysis: {
                    title: 'Analyse EEN Avancée',
                    status: 'Alimenté par IA',
                    analysisType: 'Type d\'Analyse:',
                    timePeriod: 'Période:',
                    seasonalTrends: 'Tendances Saisonnières',
                    anomalyDetection: 'Détection d\'Anomalies',
                    correlationAnalysis: 'Analyse de Corrélation',
                    comprehensiveReport: 'Rapport Compréhensif',
                    aiInsightsDiscovery: 'Découverte d\'Insights IA',
                    currentSeason: 'Saison Actuelle',
                    lastYear: 'Dernière Année',
                    last5Years: '5 Dernières Années',
                    customRange: 'Plage Personnalisée',
                    startDate: 'Date de Début:',
                    endDate: 'Date de Fin:',
                    discoveryMode: 'Mode de Découverte:',
                    targetVariable: 'Variable Cible:',
                    runAnalysis: 'Exécuter l\'Analyse',
                    reset: 'Réinitialiser'
                },
                floodWarning: {
                    title: 'Système d\'Alerte aux Inondations',
                    region: 'Région:',
                    predictionDays: 'Jours de Prédiction:',
                    redRiverBasin: 'Bassin de la Rivière Rouge',
                    winnipegMetro: 'Métro de Winnipeg',
                    manitobaProvince: 'Province du Manitoba',
                    assessFloodRisk: 'Évaluer le Risque d\'Inondation',
                    realTimeRisk: 'Risque en Temps Réel'
                },
                riskAssessment: {
                    title: 'Évaluation du Risque d\'Inondation',
                    overallRiskLevel: 'Niveau de Risque Global',
                    peakRiskPeriod: 'Période de Risque Maximal',
                    regionsAtRisk: 'Régions à Risque',
                    alertLeadTime: 'Délai d\'Alerte',
                    loadingAssessment: 'Chargement de l\'évaluation des risques d\'inondation...'
                },
                runoffPredictions: {
                    title: 'Prédictions de Ruissellement',
                    station: 'Station:',
                    loadingStations: 'Chargement des stations...'
                },
                regionalForecast: {
                    title: 'Détails des Prévisions Régionales',
                    region: 'Région',
                    currentSwe: 'EEN Actuel',
                    sevenDayForecast: 'Prévision sur 7 Jours',
                    peakRunoffDate: 'Date de Ruissellement Maximal',
                    expectedVolume: 'Volume Attendu',
                    riskLevel: 'Niveau de Risque',
                    loadingData: 'Chargement des données de prévisions régionales...'
                },
                footer: {
                    copyright: '© 2025 Système HydrAI-SWE Amélioré. Tous droits réservés.',
                    createdBy: 'Créé par',
                    systemInfo: 'Système de Prédiction d\'Équivalent en Eau de Neige et de Ruissellement',
                    systemDescription: 'Apprentissage Automatique Avancé pour la Prévision Hydrologique'
                },
                welcome: 'Bienvenue dans le Système HydrAI-SWE Amélioré',
                validation: {
                    selectDateRange: 'Veuillez sélectionner une plage de dates valide',
                    startDateError: 'La date de début ne peut pas être postérieure à la date de fin'
                },
                notifications: {
                    chartUpdated: 'Graphique mis à jour pour {region} ({startDate} au {endDate})',
                    loadingData: 'Chargement des données depuis l\'API...',
                    chartsLoaded: 'Tous les graphiques chargés avec succès',
                    updatingChart: 'Mise à jour des données du graphique...',
                    analysisComplete: 'Analyse terminée avec succès',
                    analysisFailed: 'Échec de l\'analyse'
                }
            },
            cr: {
                title: 'HydrAI-SWE ᐅᓯᑲᐅᓯᐃᑦ ᐊᓪᓚᕆᔭᐅᔪᖅ - ᐊᐳᑦ ᓂᕐᔪᑎᖓ ᐊᒻᒪ ᓴᕚᕐᔪᐊᖅ',
                subtitle: 'ᐊᓪᓚᕆᔭᐅᔪᖅ ᐊᓪᓚᑦᑎᐊᓂᐅᖅ',
                nav: {
                    dashboard: 'ᑕᑯᓐᓇᐅᔮᖅ',
                    applications: 'ᐊᑐᖅᑕᐅᔪᑦ',
                    modelTraining: 'ᐃᓕᓐᓂᐊᖅᑎᑦᑎᓂᖅ',
                    userGuide: 'ᐊᑐᖅᑐᐃᓐ ᑕᐃᑦᓯᕋᐅᑎᖓ',
                    apiReference: 'API ᑐᑭᒧᐊᒃᑲᓐᓂᖅ'
                },
                tabs: {
                    historical: 'ᐅᓰᒃᑯᑦ ᖃᐅᔨᓴᕐᓂᖅ',
                    forecast: 'ᓯᕗᓂᐊᒍᑦ ᖃᓄᐃᑦᑐᓂᒃ'
                },
                historicalSection: {
                    title: 'ᓄᓇᓕᒃᑯᑦ ᐊᐳᑦ ᓂᕐᔪᑎᖓ - ᐅᓰᒃᑯᑦ ᑕᑯᓐᓇᐅᔮᖅ',
                    status: 'ᐅᓪᓗᓕᒫᖅ ᓄᑦᑎᖅᓱᐃᔪᖅ',
                    regions: {
                        all: 'ᓄᓇᒥᐅᑕᐃᑦ ᑕᒪᒃᑯᐊ',
                        alberta: 'ᐊᓪᐸᑕ',
                        bc: 'ᐱᕆᑎᓯ ᑳᓗᒻᐱᐊ',
                        manitoba: 'ᒪᓂᑐᐸ',
                        saskatchewan: 'ᓵᔅᑲᑐᐅᓇᐃᐧᐣ'
                    },
                    dateLabels: {
                        from: 'ᓇᓕᐊᒃᓯᒪᔪᖅ:',
                        to: 'ᐱᔭᐅᔪᖅ:',
                        lastYear: 'ᐊᕐᕌᒍᖅ ᓯᕗᓪᓕᖅ',
                        last3Years: '3-ᒥᒃ ᐊᕐᕌᒍᒥᒃ ᓯᕗᓪᓕᖅ',
                        last5Years: '5-ᒥᒃ ᐊᕐᕌᒍᒥᒃ ᓯᕗᓪᓕᖅ',
                        allData: 'ᑕᒪᒃᑯᐊ ᑐᑭᓯᒋᐊᒃᓴᑦ',
                        updateChart: 'ᓄᑦᑎᖅᑎᑦᑎᓂᖅ'
                    },
                    currentSeason: {
                        title: 'ᒫᓐᓇᐅᔪᖅ ᐅᑭᐅᒥ ᓇᓗᓇᐃᒃᑯᑕᖓ',
                        totalSnow: 'ᐊᐳᑦ ᖁᓕᓂᖓ ᑲᑎᙵᓂᖓ',
                        vsHistorical: 'ᐊᒻᒪ ᐅᓰᒃᑯᑦ ᐊᐅᓚᔪᓂᒃ',
                        peakDate: 'ᑲᔪᓯᔪᓂᒃ SWE ᐅᓪᓗᖓ',
                        activeStations: 'ᐊᑐᐃᓐᓇᐅᔪᑦ ᓄᓇᓖᑦ',
                        status: 'ᐅᑭᐅᒥ ᐱᔾᔪᑎᖓ:',
                        statusText: 'ᑕᒪᒃᑯᓄᖓ ᓄᓇᓕᒃᑯᓐᓄᑦ ᐊᐳᑦ ᐊᒥᓱᐃᓂᖓ ᐅᓰᒃᑯᑦ ᒪᑦᔨᒃᓯᒪᔪᓂᒃ. ᒫᑦᔨ ᐊᓂᕐᔪᒃᐸᓪᓕᐊᓂᖓᓄᑦ ᑎᑭᓯᒪᔪᖅ.',
                        dataSources: 'ᑐᑭᓯᒋᐊᒃᓴᓂᒃ ᐱᔭᐅᔪᑦ:',
                        dataSourcesText: 'ᒫᓐᓇᐅᔪᒃᓴᐅᑎᓂᒃ ᑐᑭᓯᒋᐊᒃᓴᓂᒃ ᑲᓇᑕᐅᑉ ᐊᕙᑎᖏᓐᓄᑦ, ᑕᕝᕙ ᐊᕕᒃᑐᖅᓯᒪᔪᑦ ᐃᒪᖅᑯᑎᒋᖃᑦᑕᖅᑕᖏᓐᓄᑦ ᖃᐅᔨᓴᐅᑎᖏᓐᓄᑦ, USGS ᓴᓂᐊᓂ ᖃᓄᐃᓕᖓᔪᓕᕆᓂᖏᓐᓄᑦ ᐊᒻᒪ ᐊᐳᖅᑐᓂᒃ ᓇᒃᓴᐃᔨᓄᑦ.'
                    },
                    regionalTrends: 'SWE ᐅᑭᐅᒥᒃ ᓇᐃᓴᐅᑎᖏᑦ (ᓇᒃᓯᒪᔪᖅ 1991–2020)',
                    majorBasins: 'ᐊᖏᔪᑦ ᓄᓇᒥᐅᑕᓄᑦ ᖃᐅᔨᓴᕐᓂᖅ'
                },
                forecastSection: {
                    title: '30-ᐅᓪᓗᓂᒃ SWE ᐊᒻᒪ ᓴᕚᕐᔪᐊᖅ ᓯᕗᓂᐊᒍᑦ',
                    status: '6 ᐃᑲᕐᕋᓂᒃ ᐊᑕᐅᓯᕐᒥᒃ ᓄᑦᑎᖅᑎᑕᐅᔪᖅ',
                    forecastType: 'ᓯᕗᓂᐊᒍᑦ ᐱᓕᕆᐊᒃᓴᖓ:',
                    timeRange: 'ᐃᓅᓯᐅᑉ ᐊᓯᖏᑦ:',
                    swe: 'ᐊᐳᑦ ᓂᕐᔪᑎᖓ ᓱᓪᓗᑦᑎᐊᖓ',
                    runoff: 'ᓴᕚᕐᔪᐊᖅ ᐊᖏᓂᖓ',
                    combined: 'ᑲᑎᙵᔪᖅ ᑕᑯᓐᓇᓂᖅ',
                    days7: '7 ᐅᓪᓗᑦ',
                    days14: '14 ᐅᓪᓗᑦ',
                    days30: '30 ᐅᓪᓗᑦ',
                    days60: '60 ᐅᓪᓗᑦ',
                    days120: '4 ᑕᖅᑮᑦ',
                    forecastStartDate: 'ᓯᕗᓂᐊᒍᑦ ᐱᒋᐊᕈᑎᖓ:',
                    fromToday: 'ᐅᓪᓗᒥᒃ ᐱᒋᐊᕐᓗᒍ',
                    fromNovember: 'ᓄᕕᐱᕆᒥᒃ ᐱᒋᐊᕐᓗᒍ',
                    fromDecember: 'ᑎᓯᐱᕆᒥᒃ ᐱᒋᐊᕐᓗᒍ',
                    fromJanuary: 'ᔭᓐᓄᐊᓕᒥᒃ ᐱᒋᐊᕐᓗᒍ',
                    updateForecast: 'ᓯᕗᓂᐊᒍᑦ ᓄᑦᑎᖅᑎᑦᑎᓂᖅ'
                },
                sweAnalysis: {
                    title: 'ᐊᒃᓱᕉᑎᖅ SWE ᖃᐅᔨᓴᕐᓂᖅ',
                    status: 'AI-ᒧᑦ ᐱᔨᑦᑎᖅᑕᐅᔪᖅ',
                    analysisType: 'ᖃᐅᔨᓴᕐᓂᐅᑉ ᐊᓈᓇᖓ:',
                    timePeriod: 'ᐃᓅᓯᐅᑉ ᐊᓂᒍᖅᓯᒪᓂᖓ:',
                    seasonalTrends: 'ᐅᑭᐅᒥᒃ ᐊᓯᔾᔨᖅᐸᓪᓕᐊᔪᑦ',
                    anomalyDetection: 'ᐊᓪᓕᐅᖏᑦᑐᓂᒃ ᓇᓂᓯᓂᖅ',
                    correlationAnalysis: 'ᓴᓂᕐᕙᐅᓂᕐᒧᑦ ᖃᐅᔨᓴᕐᓂᖅ',
                    comprehensiveReport: 'ᑕᒪᒃᑯᓂᖓ ᑐᑭᓯᓇᐃᒃᑯᑕᖅ',
                    aiInsightsDiscovery: 'AI ᑐᑭᓯᒋᐊᒃᓴᓂᒃ ᓇᓂᓯᓂᖅ',
                    currentSeason: 'ᒫᓐᓇᐅᔪᖅ ᐅᑭᐅ',
                    lastYear: 'ᓯᕗᓪᓕᖅᐹᖅ ᐊᕐᕌᒍ',
                    last5Years: '5 ᓯᕗᓪᓕᖅᐹᑦ ᐊᕐᕌᒍᑦ',
                    customRange: 'ᐅᕙᒍᑦ ᓂᕈᐊᖅᑕᖓ',
                    startDate: 'ᐱᒋᐊᕐᓂᖓ:',
                    endDate: 'ᐃᓱᓕᕐᓂᖓ:',
                    discoveryMode: 'ᓇᓂᓯᓂᐅᑉ ᐊᓈᓇᖓ:',
                    targetVariable: 'ᑐᕌᖓᔪᖅ ᐊᓯᔾᔨᖅᐸᓪᓕᐊᔪᖅ:',
                    runAnalysis: 'ᖃᐅᔨᓴᕐᓂᖅ ᐱᒋᐊᖅᑎᑦᑎᓂᖅ',
                    reset: 'ᓄᑦᑎᖅᑎᑦᑎᓂᖅ'
                },
                floodWarning: {
                    title: 'ᐊᒃᑐᖅᑎᕆᔪᓄᑦ ᖃᐅᒪᔪᓄᑦ ᐊᖏᖅᓯᒪᔪᖅ',
                    region: 'ᓄᓇᓯᐅᑉ ᐊᕕᒃᑐᖅᓯᒪᓂᖓ:',
                    predictionDays: 'ᓯᕗᒧᐊᕈᑕᐅᔪᑦ ᐅᓪᓗᑦ:',
                    redRiverBasin: 'ᐊᐅᓪᓛᖅ ᑯᖓᓂ ᓇᔭᖓ',
                    winnipegMetro: 'ᑯᐃᓂᐸᒡ ᓄᓇᖓᑕ ᐊᕕᒃᑐᖅᓯᒪᓂᖓ',
                    manitobaProvince: 'ᒪᓂᑐᐸ ᑕᕝᕙᓂ',
                    assessFloodRisk: 'ᖃᐅᒪᔪᓄᑦ ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓᓂᒃ ᖃᐅᔨᓴᕐᓂᖅ',
                    realTimeRisk: 'ᒫᓐᓇᐅᔪᖅ ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓ'
                },
                riskAssessment: {
                    title: 'ᖃᐅᒪᔪᓄᑦ ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓᓂᒃ ᖃᐅᔨᓴᕐᓂᖅ',
                    overallRiskLevel: 'ᑕᒪᒃᑯᓂᖓ ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓᑕ ᑯᓚᐅᔾᔭᐃᓂᖓ',
                    peakRiskPeriod: 'ᖁᑦᑎᖅᓯᒪᔪᓂ ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓᑕ ᐃᓚᒋᔭᐅᓂᖓ',
                    regionsAtRisk: 'ᓄᓇᓖᑦ ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓᓂ',
                    alertLeadTime: 'ᖃᐅᒪᔪᓂᒃ ᓇᓗᓇᐃᖅᓯᓂᐅᑉ ᓯᕗᓂᐊᒍᑦ ᐃᓕᓐᓂᐊᖅᑎᑦᑎᓂᖓ',
                    loadingAssessment: 'ᖃᐅᒪᔪᓄᑦ ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓᓂᒃ ᖃᐅᔨᓴᕐᓂᖅ ᐃᖅᑲᖅᑐᐃᔪᖅ...'
                },
                runoffPredictions: {
                    title: 'ᓴᕚᕐᔪᐊᖅ ᓯᕗᒧᐊᕈᑕᐅᔪᑦ',
                    station: 'ᓄᓇᓯᐅᑉ ᐃᓂᖓ:',
                    loadingStations: 'ᓄᓇᓯᐅᑉ ᐃᓂᖏᑦ ᐃᖅᑲᖅᑐᐃᔪᑦ...'
                },
                regionalForecast: {
                    title: 'ᓄᓇᓕᒃᑯᑦ ᓯᕗᒧᐊᕈᑕᐅᔪᑦ ᓇᓗᓇᐃᒃᑯᑕᖏᑦ',
                    region: 'ᓄᓇᓯᐅᑉ ᐊᕕᒃᑐᖅᓯᒪᓂᖓ',
                    currentSwe: 'ᒫᓐᓇᐅᔪᖅ SWE',
                    sevenDayForecast: '7-ᐅᓪᓗᓄᑦ ᓯᕗᒧᐊᕈᑎ',
                    peakRunoffDate: 'ᖁᑦᑎᖅᓯᒪᔪᖅ ᓴᕚᕐᔪᐊᖅ ᐅᓪᓗᖓ',
                    expectedVolume: 'ᓂᕆᐅᒋᔭᐅᔪᖅ ᐊᖏᓂᖓ',
                    riskLevel: 'ᐱᑦᔪᑎᒋᓂᐊᖅᑕᖓᑕ ᑯᓚᐅᔾᔭᐃᓂᖓ',
                    loadingData: 'ᓄᓇᓕᒃᑯᑦ ᓯᕗᒧᐊᕈᑕᐅᔪᑦ ᑐᑭᓯᒋᐊᒃᓴᖏᑦ ᐃᖅᑲᖅᑐᐃᔪᑦ...'
                },
                footer: {
                    copyright: '© 2025 HydrAI-SWE ᐊᓪᓚᕆᔭᐅᔪᖅ ᐊᓪᓚᑦᑎᐊᓂᐅᖅ. ᑕᒪᒃᑯᐊ ᐱᔪᓐᓇᐅᑏᑦ ᓴᐳᒻᒥᔭᐅᔪᑦ.',
                    createdBy: 'ᓴᓇᔭᐅᔪᖅ',
                    systemInfo: 'ᐊᐳᑦ ᓂᕐᔪᑎᖓ ᐊᒻᒪ ᓴᕚᕐᔪᐊᖅ ᓯᕗᒧᐊᕈᑕᐅᔪᓄᑦ ᐊᓪᓚᑦᑎᐊᓂᐅᖅ',
                    systemDescription: 'ᐊᒃᓱᕉᑎᖅ ᐅᓗᕆᐊᓇᖅᑑᔾᔪᓯᐅᖅᐸᒃᑐᖅ ᐃᒪᖅᑯᑎᒋᓕᐅᕈᑎᓄᑦ ᓯᕗᒧᐊᕈᑎᓄᑦ'
                },
                welcome: 'ᑐᓐᖓᓱᒍᓐᓇᖅᑐᖅ HydrAI-SWE ᐊᓪᓚᕆᔭᐅᔪᒧᑦ ᐊᓪᓚᑦᑎᐊᓂᐅᒧᑦ',
                validation: {
                    selectDateRange: 'ᐅᓪᓗᓯᐅᕈᓐᓇᖅᑐᓂᒃ ᓂᕈᐊᖅᑕᐅᔪᓂᒃ ᓂᕈᐊᕐᓗᒍ',
                    startDateError: 'ᐱᒋᐊᖅᑐᐃᔨᐅᔪᖅ ᐅᓪᓗᖓ ᑭᖑᓪᓕᖅᐹᖑᔪᓐᓇᖏᓐᓇᖅ'
                },
                notifications: {
                    chartUpdated: 'ᑎᑎᕋᖅᓯᒪᔪᖅ ᓄᑦᑎᖅᑎᑕᐅᓯᒪᔪᖅ {region} ({startDate} ᐊᒻᒪ {endDate})',
                    loadingData: 'API-ᒥᒃ ᑐᑭᓯᒋᐊᒃᓴᓂᒃ ᐃᖅᑲᖅᑐᐃᔪᖅ...',
                    chartsLoaded: 'ᑕᒪᒃᑯᐊ ᑎᑎᕋᖅᓯᒪᔪᑦ ᐱᔭᕇᖅᓯᒪᔪᑦ',
                    updatingChart: 'ᑎᑎᕋᖅᓯᒪᔪᑦ ᑐᑭᓯᒋᐊᒃᓴᖏᓐᓂᒃ ᓄᑦᑎᖅᑎᑦᑎᔪᖅ...',
                    analysisComplete: 'ᖃᐅᔨᓴᕐᓂᖅ ᐱᔭᕇᖅᓯᒪᔪᖅ',
                    analysisFailed: 'ᖃᐅᔨᓴᕐᓂᖅ ᐃᓱᒫᓗᒋᔭᖃᖅᓯᒪᔪᖅ'
                }
            }
        };
        
        // 语言切换功能已移除，减少页面加载
        
        // Load and populate current season summary data
        async function loadCurrentSeasonSummary() {
            try {
                console.log('Loading current season summary...');
                const data = await fetchCurrentSeasonSummary();
                console.log('Current season summary data received:', data);
                
                // Update metric values
                const totalSnowEl = document.getElementById('total-snow-value');
                const vsHistoricalEl = document.getElementById('vs-historical-value');
                const peakDateEl = document.getElementById('peak-date-value');
                const activeStationsEl = document.getElementById('active-stations-value');
                
                console.log('Found elements:', { totalSnowEl, vsHistoricalEl, peakDateEl, activeStationsEl });
                
                if (totalSnowEl && data.total_snow) {
                    totalSnowEl.textContent = data.total_snow.value;
                    console.log('Updated total snow:', data.total_snow.value);
                }
                if (vsHistoricalEl && data.vs_historical) {
                    vsHistoricalEl.textContent = data.vs_historical.value;
                    console.log('Updated vs historical:', data.vs_historical.value);
                }
                if (peakDateEl && data.peak_date) {
                    peakDateEl.textContent = data.peak_date.value;
                    console.log('Updated peak date:', data.peak_date.value);
                }
                if (activeStationsEl && data.active_stations) {
                    activeStationsEl.textContent = data.active_stations.value;
                    console.log('Updated active stations:', data.active_stations.value);
                }
                
                console.log('Current season summary loaded successfully');
                
            } catch (error) {
                console.error('Failed to load current season summary:', error);
                // Set fallback values instead of keeping loading state
                const elements = ['total-snow-value', 'vs-historical-value', 'peak-date-value', 'active-stations-value'];
                elements.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = 'Data unavailable';
                });
            }
        }
        
        // Load and populate flood risk assessment
        async function loadFloodRiskAssessment() {
            try {
                const data = await fetchFloodRiskAssessment();
                
                // Update risk assessment metrics
                const riskLevelEl = document.getElementById('risk-level-value');
                const peakRiskEl = document.getElementById('peak-risk-period-value');
                const regionsAtRiskEl = document.getElementById('regions-at-risk-value');
                const alertLeadTimeEl = document.getElementById('alert-lead-time-value');
                const floodAlertEl = document.getElementById('flood-alert-content');
                
                // Map API data to frontend elements
                if (riskLevelEl) {
                    riskLevelEl.textContent = data.overall_risk || 'Unknown';
                    // Set color based on risk level
                    if (data.overall_risk === 'HIGH') {
                        riskLevelEl.style.color = '#e74c3c';
                    } else if (data.overall_risk === 'MEDIUM') {
                        riskLevelEl.style.color = '#f39c12';
                    } else {
                        riskLevelEl.style.color = '#27ae60';
                    }
                }
                
                if (peakRiskEl) {
                    peakRiskEl.textContent = `${data.prediction_days} days forecast`;
                }
                
                if (regionsAtRiskEl) {
                    regionsAtRiskEl.textContent = data.region || 'Red River Basin';
                }
                
                if (alertLeadTimeEl) {
                    const highRiskPct = data.risk_statistics?.high_risk_percentage || 0;
                    alertLeadTimeEl.textContent = `${highRiskPct}% high risk areas`;
                }
                
                if (floodAlertEl) {
                    const riskLevel = data.overall_risk || 'Unknown';
                    const highRiskCount = data.risk_statistics?.high_risk_count || 0;
                    floodAlertEl.textContent = `Current risk level: ${riskLevel}. ${highRiskCount} high-risk areas detected.`;
                }
                
            } catch (error) {
                console.error('Failed to load flood risk assessment:', error);
                // Set fallback values
                const elements = ['risk-level-value', 'peak-risk-period-value', 'regions-at-risk-value', 'alert-lead-time-value'];
                elements.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = 'Data unavailable';
                });
                
                const floodAlertEl = document.getElementById('flood-alert-content');
                if (floodAlertEl) floodAlertEl.textContent = 'Flood risk assessment unavailable';
            }
        }
        
        // Load and populate regional forecast table
        async function loadRegionalForecastDetails() {
            try {
                const data = await fetchRegionalForecastDetails();
                const tableBody = document.getElementById('regional-forecast-table');
                
                if (!tableBody) return;
                
                // Clear loading message
                tableBody.innerHTML = '';
                
                // Check if data has regions
                if (data && data.regions && Array.isArray(data.regions)) {
                // Populate table with regional forecast data
                data.regions.forEach(region => {
                    const row = document.createElement('tr');
                    
                    // Add risk level styling
                        const riskClass = region.risk_level && region.risk_level.includes('High') ? 'style="color: #e74c3c; font-weight: bold;"' :
                                         region.risk_level && region.risk_level.includes('Moderate') ? 'style="color: #f39c12; font-weight: bold;"' :
                                         region.risk_level && region.risk_level.includes('Low') ? 'style="color: #27ae60; font-weight: bold;"' :
                                     'style="color: #95a5a6; font-weight: bold;"';
                    
                    // Add forecast change styling
                        const forecastClass = region.forecast_7day && region.forecast_7day.startsWith('+') ? 'style="color: #3498db;"' :
                                             region.forecast_7day && region.forecast_7day.startsWith('-') ? 'style="color: #e67e22;"' :
                                         'style="color: #95a5a6;"';
                    
                    row.innerHTML = `
                            <td>${region.name || 'N/A'}</td>
                            <td>${region.current_swe || 'N/A'}</td>
                            <td ${forecastClass}>${region.forecast_7day || 'N/A'}</td>
                            <td>${region.peak_runoff_date || 'N/A'}</td>
                            <td>${region.expected_volume || 'N/A'}</td>
                            <td ${riskClass}>${region.risk_level || 'N/A'}</td>
                    `;
                    
                    tableBody.appendChild(row);
                });
                } else {
                    // Show no data message
                    tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666;">No regional forecast data available</td></tr>';
                }
                
            } catch (error) {
                console.error('Failed to load regional forecast details:', error);
                // Show error message in table
                const tableBody = document.getElementById('regional-forecast-table');
                if (tableBody) {
                    tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #e74c3c;">Failed to load regional forecast data</td></tr>';
                }
            }
        }
        
        // Initialize all data loading
        async function initializeAllData() {
            try {
                console.log('Starting to initialize all data...');
                
                // Load data components individually with better error handling
                console.log('Loading current season summary...');
                await loadCurrentSeasonSummary();
                
                console.log('Loading flood risk assessment...');
                await loadFloodRiskAssessment();
                
                console.log('Loading regional forecast details...');
                await loadRegionalForecastDetails();
                
                console.log('All data components loaded successfully');
                showNotification('Dashboard data loaded successfully', 'success');
                
            } catch (error) {
                console.error('Failed to load all data:', error);
                console.log('Loading fallback data due to API issues...');
                await loadFallbackData();
                showNotification('Using fallback data due to API connection issues', 'warning');
            }
        }
        
        // Load fallback data when API fails
        async function loadFallbackData() {
            try {
                console.log('Loading fallback data...');
                
                // Set fallback values for current season summary
                const totalSnowEl = document.getElementById('total-snow-value');
                const vsHistoricalEl = document.getElementById('vs-historical-value');
                const peakDateEl = document.getElementById('peak-date-value');
                const activeStationsEl = document.getElementById('active-stations-value');
                
                if (totalSnowEl) totalSnowEl.textContent = '95.0 mm';
                if (vsHistoricalEl) vsHistoricalEl.textContent = '0%';
                if (peakDateEl) peakDateEl.textContent = 'Dec 19';
                if (activeStationsEl) activeStationsEl.textContent = '2';
                
                // Set fallback values for flood risk assessment
                const riskLevelEl = document.getElementById('risk-level-value');
                const peakRiskEl = document.getElementById('peak-risk-period-value');
                const regionsAtRiskEl = document.getElementById('regions-at-risk-value');
                const alertLeadTimeEl = document.getElementById('alert-lead-time-value');
                const floodAlertEl = document.getElementById('flood-alert-content');
                
                if (riskLevelEl) riskLevelEl.textContent = 'LOW';
                if (peakRiskEl) peakRiskEl.textContent = 'Mar-Apr 2025';
                if (regionsAtRiskEl) regionsAtRiskEl.textContent = 'None';
                if (alertLeadTimeEl) alertLeadTimeEl.textContent = '48 hours';
                if (floodAlertEl) floodAlertEl.textContent = 'Current conditions indicate low flood risk. Monitor weather forecasts for changes.';
                
                // Set fallback values for regional forecast table
                const tableBody = document.getElementById('regional-forecast-table');
                if (tableBody) {
                    tableBody.innerHTML = `
                        <tr>
                            <td>Manitoba</td>
                            <td>45.2 mm</td>
                            <td>+2.1 mm</td>
                            <td>Mar 15, 2025</td>
                            <td>2.3 m³/s</td>
                            <td>LOW</td>
                        </tr>
                        <tr>
                            <td>Alberta</td>
                            <td>38.7 mm</td>
                            <td>-1.2 mm</td>
                            <td>Mar 22, 2025</td>
                            <td>1.8 m³/s</td>
                            <td>LOW</td>
                        </tr>
                        <tr>
                            <td>BC</td>
                            <td>67.3 mm</td>
                            <td>+5.4 mm</td>
                            <td>Mar 10, 2025</td>
                            <td>3.1 m³/s</td>
                            <td>MODERATE</td>
                        </tr>
                    `;
                }
                
                console.log('Fallback data loaded successfully');
                
            } catch (error) {
                console.error('Failed to load fallback data:', error);
                showNotification('Failed to load any data. Please refresh the page.', 'error');
            }
        }
        
        // Initialize language system
        function initializeLanguageSystem() {
            // Set dropdown to reflect saved language preference
            const savedLanguage = localStorage.getItem('selectedLanguage') || 'en';
            const languageSelect = document.getElementById('languageSelect');
            if (languageSelect) {
                languageSelect.value = savedLanguage;
            }
        }
        

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('HydrAI-SWE Enhanced System initialized');
            
            // Initialize language system
            initializeLanguageSystem();
            
            // Initialize interactive components
            initializeForecastControls();
            
            // Initialize forecast date to today
            initializeForecastDate();
            
            // Initialize runoff station dropdown
            initializeRunoffStations();
            
            // Load insight discovery configuration
            loadInsightDiscoveryConfig();
            
            // Initialize charts only
            initializeCharts().catch(error => {
                console.warn('Charts initialization failed:', error);
            });
            
            // Force load dashboard data with better error handling
            showNotification('Loading dashboard data...', 'info');
            
            // Initialize all data with proper error handling
            setTimeout(async () => {
                try {
                await initializeAllData();
                    
                    // After dashboard loads, update region availability
                    const startDate = document.getElementById('start-date')?.value;
                    const endDate = document.getElementById('end-date')?.value;
                    if (startDate && endDate) {
                await updateRegionAvailability(startDate, endDate);
                    }
                    
                // Optionally kick off a default analysis run
                    setTimeout(() => {
                runSweAnalysisFromUI();
                    }, 500);
                    
                } catch (error) {
                    console.error('Dashboard initialization failed:', error);
                }
            }, 200); // Small delay to ensure DOM is ready
        });

        // Flood Warning System Functions
        async function assessFloodRisk() {
            const region = document.getElementById('flood-region').value;
            const days = document.getElementById('flood-days').value;
            const resultsDiv = document.getElementById('flood-risk-results');
            
            resultsDiv.innerHTML = '<div class="alert alert-info"><i class="fas fa-spinner fa-spin"></i> Assessing flood risk...</div>';
            
            try {
                // 直接调用API，不需要额外的baseUrl
                const data = await apiRequest(`/api/v1/flood/risk-assessment?days=${days}&region=${region}`);
                
                if (data.status === 'success') {
                    const riskClass = data.overall_risk === 'HIGH' ? 'alert-danger' : 
                                    data.overall_risk === 'MEDIUM' ? 'alert-warning' : 'alert-success';
                    
                    resultsDiv.innerHTML = `
                        <div class="alert ${riskClass}">
                            <h4><i class="fas fa-exclamation-triangle"></i> Flood Risk Assessment</h4>
                            <div class="grid">
                                <div>
                                    <strong>Overall Risk:</strong> <span class="badge ${riskClass.replace('alert-', '')}">${data.overall_risk}</span>
                                </div>
                                <div>
                                    <strong>Region:</strong> ${data.region.replace('-', ' ').toUpperCase()}
                                </div>
                                <div>
                                    <strong>Prediction Days:</strong> ${data.prediction_days}
                                </div>
                            </div>
                            <div class="mt-2">
                                <strong>Risk Statistics:</strong>
                                <ul>
                                    <li>Total Samples: ${data.risk_statistics.total_samples}</li>
                                    <li>High Risk Count: ${data.risk_statistics.high_risk_count} (${data.risk_statistics.high_risk_percentage}%)</li>
                                    <li>Average Risk Probability: ${data.risk_statistics.average_risk_probability}%</li>
                                </ul>
                            </div>
                            <div class="mt-2">
                                <strong>Model Info:</strong> ${data.model_info.model_type} with ${data.model_info.features_count} features, ${data.model_info.accuracy} accuracy
                            </div>
                        </div>
                    `;
                } else {
                    resultsDiv.innerHTML = '<div class="alert alert-danger">Assessment failed</div>';
                }
            } catch (error) {
                resultsDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }
        
        async function getRealTimeRisk() {
            const displayDiv = document.getElementById('real-time-risk-display');
            
            displayDiv.innerHTML = '<div class="alert alert-info"><i class="fas fa-spinner fa-spin"></i> Getting real-time risk...</div>';
            
            try {
                // 直接调用API，不需要额外的baseUrl
                const data = await apiRequest('/api/v1/flood/real-time-risk');
                
                if (data.status === 'success') {
                    const riskClass = data.current_risk.level === 'HIGH' ? 'alert-danger' : 'alert-success';
                    
                    // 获取当前语言
                    const currentLang = document.documentElement.lang || 'en';
                    
                    // 获取对应语言的描述和推荐
                    const description = typeof data.current_risk.description === 'object' ? 
                        data.current_risk.description[currentLang] || data.current_risk.description.en : 
                        data.current_risk.description;
                    const action = typeof data.recommendation.action === 'object' ? 
                        data.recommendation.action[currentLang] || data.recommendation.action.en : 
                        data.recommendation.action;
                    const monitoring = typeof data.recommendation.monitoring === 'object' ? 
                        data.recommendation.monitoring[currentLang] || data.recommendation.monitoring.en : 
                        data.recommendation.monitoring;
                    
                    displayDiv.innerHTML = `
                        <div class="alert ${riskClass}">
                            <h4><i class="fas fa-clock"></i> Real-time Flood Risk</h4>
                            <div class="grid">
                                <div>
                                    <strong>Current Risk:</strong> <span class="badge ${riskClass.replace('alert-', '')}">${data.current_risk.level}</span>
                                </div>
                                <div>
                                    <strong>Risk Probability:</strong> ${data.current_risk.probability}%
                                </div>
                                <div>
                                    <strong>Data Date:</strong> ${new Date(data.data_date).toLocaleDateString()}
                                </div>
                            </div>
                            <div class="mt-2">
                                <strong>Description:</strong> ${description}
                            </div>
                            <div class="mt-2">
                                <strong>Recommendation:</strong>
                                <ul>
                                    <li><strong>Action:</strong> ${action}</li>
                                    <li><strong>Monitoring:</strong> ${monitoring}</li>
                                </ul>
                            </div>
                        </div>
                    `;
                } else {
                    displayDiv.innerHTML = '<div class="alert alert-danger">Failed to get real-time risk</div>';
                }
            } catch (error) {
                displayDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }
        
        // ========================================
        // PREDICTION VALIDATION FUNCTIONS
        // ========================================
        
        // Chart instances for validation
        let qualityTrendChart, consistencyComparisonChart, validationHistoryChart;
        let validationTaskInterval = null;
        
        // Fetch prediction validation from backend
        async function fetchPredictionValidation(predictions, variableType, modelName, modelVersion = 'v1') {
            const API_VALIDATION_URL = '/api/v1/prediction-validation';
            return await apiRequest('/validate', {
                method: 'POST',
                body: JSON.stringify({
                    predictions: predictions,
                    variable_type: variableType,
                    model_name: modelName,
                    model_version: modelVersion
                })
            }, API_VALIDATION_URL);
        }
        
        // Fetch multi-source consistency validation
        async function fetchConsistencyValidation(primaryPredictions, comparisonPredictions, variableType) {
            const API_VALIDATION_URL = '/api/v1/prediction-validation';
            return await apiRequest('/multi-source-consistency', {
                method: 'POST',
                body: JSON.stringify({
                    primary_predictions: primaryPredictions,
                    comparison_predictions: comparisonPredictions,
                    variable_type: variableType
                })
            }, API_VALIDATION_URL);
        }
        
        // Fetch validation history
        async function fetchValidationHistory() {
            const API_VALIDATION_URL = '/api/v1/prediction-validation';
            return await apiRequest('/history', {}, API_VALIDATION_URL);
        }
        
        // Fetch real-time validation tasks
        async function fetchValidationTasks() {
            const API_VALIDATION_URL = '/api/v1/prediction-validation';
            return await apiRequest('/tasks', {}, API_VALIDATION_URL);
        }
        
        // Start real-time validation task
        async function startValidationTask(predictions, variableType, modelName) {
            const API_VALIDATION_URL = '/api/v1/prediction-validation';
            return await apiRequest('/tasks/start', {
                method: 'POST',
                body: JSON.stringify({
                    predictions: predictions,
                    variable_type: variableType,
                    model_name: modelName
                })
            }, API_VALIDATION_URL);
        }
        
        // Generate sample prediction data for demonstration
        function generateSamplePredictions(variableType, count = 100) {
            const predictions = [];
            for (let i = 0; i < count; i++) {
                let value;
                switch (variableType) {
                    case 'swe':
                        value = Math.max(0, 50 + Math.random() * 100 + Math.sin(i / 10) * 30);
                        break;
                    case 'runoff':
                        value = Math.max(5, 25 + Math.random() * 50 + Math.sin(i / 15) * 20);
                        break;
                    case 'soil_moisture':
                        value = Math.max(0.1, 0.3 + Math.random() * 0.4);
                        break;
                    case 'temperature':
                        value = -10 + Math.random() * 40;
                        break;
                    default:
                        value = Math.random() * 100;
                }
                predictions.push(value);
            }
            return predictions;
        }
        
        // Main prediction quality validation function
        async function validatePredictionQuality() {
            const variableSelect = document.getElementById('validation-variable-select');
            const modelSelect = document.getElementById('validation-model-select');
            const resultsDiv = document.getElementById('validation-results');
            
            const variableType = variableSelect.value;
            const modelName = modelSelect.value;
            
            resultsDiv.className = 'alert alert-info';
            resultsDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i><div>Running prediction validation...</div>';
            
            try {
                // Generate sample predictions for demonstration
                const predictions = generateSamplePredictions(variableType);
                
                // Call validation API
                const validationResult = await fetchPredictionValidation(predictions, variableType, modelName);
                
                if (validationResult.status === 'success') {
                    updateQualityMetrics(validationResult.validation_results);
                    
                    resultsDiv.className = 'alert alert-success';
                    resultsDiv.innerHTML = `
                        <i class="fas fa-check-circle"></i>
                        <div>
                            <strong>Validation Complete</strong><br>
                            Overall Quality Score: <strong>${validationResult.validation_results.overall_quality_score.toFixed(2)}</strong><br>
                            Physical constraints: ${validationResult.validation_results.physical_constraint_violations} violations<br>
                            Anomaly detection: ${validationResult.validation_results.anomaly_detection_results.anomaly_count} anomalies found
                        </div>
                    `;
                } else {
                    throw new Error(validationResult.message || 'Validation failed');
                }
                
            } catch (error) {
                console.error('Prediction validation failed:', error);
                resultsDiv.className = 'alert alert-danger';
                resultsDiv.innerHTML = `
                    <i class="fas fa-exclamation-circle"></i>
                    <div>
                        <strong>Validation Failed</strong><br>
                        Error: ${error.message}
                    </div>
                `;
            }
        }
        
        // Update quality metrics display
        function updateQualityMetrics(results) {
            document.getElementById('overall-quality-value').textContent = results.overall_quality_score.toFixed(2);
            document.getElementById('physical-constraint-value').textContent = results.physical_constraint_violations + ' violations';
            document.getElementById('anomaly-rate-value').textContent = (results.anomaly_detection_results.anomaly_rate * 100).toFixed(1) + '%';
            
            // Update consistency score if available
            if (results.multi_source_consistency) {
                document.getElementById('consistency-score-value').textContent = results.multi_source_consistency.consistency_score.toFixed(2);
            } else {
                document.getElementById('consistency-score-value').textContent = '--';
            }
            
            // Update quality trend chart
            updateQualityTrendChart(results);
        }
        
        // Update quality trend chart
        function updateQualityTrendChart(results) {
            const ctx = document.getElementById('quality-trend-chart').getContext('2d');
            
            if (qualityTrendChart) {
                qualityTrendChart.destroy();
            }
            
            // Generate trend data (in a real system, this would come from historical data)
            const labels = ['24h ago', '18h ago', '12h ago', '6h ago', 'Now'];
            const trendData = [
                results.overall_quality_score - 0.15,
                results.overall_quality_score - 0.10,
                results.overall_quality_score - 0.05,
                results.overall_quality_score + 0.02,
                results.overall_quality_score
            ];
            
            qualityTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Quality Score Trend',
                        data: trendData,
                        borderColor: '#4A90E2',
                        backgroundColor: 'rgba(74, 144, 226, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            min: Math.max(0, Math.min(...trendData) - 0.1),
                            max: Math.min(1, Math.max(...trendData) + 0.1)
                        }
                    }
                }
            });
        }
        
        // Multi-source consistency validation
        async function validateConsistency() {
            const primaryModelSelect = document.getElementById('primary-model-select');
            const comparisonModelsSelect = document.getElementById('comparison-models-select');
            const resultsDiv = document.getElementById('consistency-results');
            
            const primaryModel = primaryModelSelect.value;
            const comparisonModels = Array.from(comparisonModelsSelect.selectedOptions).map(option => option.value);
            
            if (comparisonModels.length === 0) {
                resultsDiv.className = 'alert alert-warning';
                resultsDiv.innerHTML = '<i class="fas fa-exclamation-triangle"></i><div>Please select at least one comparison model.</div>';
                return;
            }
            
            resultsDiv.className = 'alert alert-info';
            resultsDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i><div>Validating consistency across models...</div>';
            
            try {
                // Generate sample predictions for different models
                const primaryPredictions = generateSamplePredictions('swe');
                const comparisonPredictions = {};
                
                comparisonModels.forEach(model => {
                    comparisonPredictions[model] = generateSamplePredictions('swe').map(val => 
                        val * (0.9 + Math.random() * 0.2) // Add some variation
                    );
                });
                
                // Call consistency validation API
                const consistencyResult = await fetchConsistencyValidation(
                    primaryPredictions,
                    comparisonPredictions,
                    'swe'
                );
                
                if (consistencyResult.status === 'success') {
                    updateConsistencyChart(consistencyResult.consistency_analysis);
                    
                    resultsDiv.className = 'alert alert-success';
                    resultsDiv.innerHTML = `
                        <i class="fas fa-check-double"></i>
                        <div>
                            <strong>Consistency Analysis Complete</strong><br>
                            Overall Consistency Score: <strong>${consistencyResult.consistency_analysis.overall_consistency_score.toFixed(2)}</strong><br>
                            Models analyzed: ${comparisonModels.length + 1}<br>
                            Correlation range: ${consistencyResult.consistency_analysis.correlation_range.min.toFixed(2)} - ${consistencyResult.consistency_analysis.correlation_range.max.toFixed(2)}
                        </div>
                    `;
                } else {
                    throw new Error(consistencyResult.message || 'Consistency validation failed');
                }
                
            } catch (error) {
                console.error('Consistency validation failed:', error);
                resultsDiv.className = 'alert alert-danger';
                resultsDiv.innerHTML = `
                    <i class="fas fa-exclamation-circle"></i>
                    <div>
                        <strong>Consistency Validation Failed</strong><br>
                        Error: ${error.message}
                    </div>
                `;
            }
        }
        
        // Update consistency comparison chart
        function updateConsistencyChart(analysisData) {
            const ctx = document.getElementById('consistency-comparison-chart').getContext('2d');
            
            if (consistencyComparisonChart) {
                consistencyComparisonChart.destroy();
            }
            
            // Extract model comparison data
            const models = Object.keys(analysisData.model_correlations);
            const correlations = Object.values(analysisData.model_correlations);
            
            consistencyComparisonChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: models,
                    datasets: [{
                        label: 'Model Correlation with Primary',
                        data: correlations,
                        borderColor: '#4A90E2',
                        backgroundColor: 'rgba(74, 144, 226, 0.2)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Multi-Model Consistency Analysis'
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                stepSize: 0.2
                            }
                        }
                    }
                }
            });
        }
        
        // Start real-time validation monitoring
        async function startRealTimeValidation() {
            const variableSelect = document.getElementById('validation-variable-select');
            const modelSelect = document.getElementById('validation-model-select');
            
            const variableType = variableSelect.value;
            const modelName = modelSelect.value;
            
            try {
                // Generate sample predictions for monitoring
                const predictions = generateSamplePredictions(variableType, 50);
                
                // Start validation task
                const taskResult = await startValidationTask(predictions, variableType, modelName);
                
                if (taskResult.status === 'success') {
                    showNotification('Real-time validation monitoring started', 'success');
                    
                    // Start polling for task updates
                    validationTaskInterval = setInterval(updateValidationTasks, 5000);
                    updateValidationTasks(); // Initial update
                } else {
                    throw new Error(taskResult.message || 'Failed to start monitoring');
                }
                
            } catch (error) {
                console.error('Failed to start real-time validation:', error);
                showNotification('Failed to start real-time validation: ' + error.message, 'error');
            }
        }
        
        // Update validation tasks display
        async function updateValidationTasks() {
            try {
                const tasksData = await fetchValidationTasks();
                const taskList = document.getElementById('validation-task-list');
                
                if (tasksData.active_tasks && tasksData.active_tasks.length > 0) {
                    taskList.innerHTML = tasksData.active_tasks.map(task => `
                        <div class="task-item" style="padding: 0.8rem; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 600; color: #2c3e50;">${task.model_name}</div>
                                <div style="font-size: 0.85rem; color: #666;">${task.variable_type} • ${task.status}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.9rem; font-weight: 600; color: ${task.quality_score >= 0.8 ? '#27ae60' : task.quality_score >= 0.6 ? '#f39c12' : '#e74c3c'};">
                                    ${(task.quality_score * 100).toFixed(0)}%
                                </div>
                                <div style="font-size: 0.75rem; color: #999;">
                                    ${new Date(task.last_update).toLocaleTimeString()}
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    taskList.innerHTML = '<div class="task-item" style="padding: 0.5rem; border-bottom: 1px solid #eee;"><div style="color: #666; font-size: 0.9rem;">No active validation tasks</div></div>';
                }
                
            } catch (error) {
                console.error('Failed to update validation tasks:', error);
            }
        }
        
        // Reset validation interface
        function resetValidation() {
            // Clear results
            document.getElementById('validation-results').className = 'alert alert-info';
            document.getElementById('validation-results').innerHTML = '<i class="fas fa-info-circle"></i><div>Select model and variable type to begin prediction validation.</div>';
            
            document.getElementById('consistency-results').className = 'alert alert-info';
            document.getElementById('consistency-results').innerHTML = '<i class="fas fa-info-circle"></i><div>Select models to compare prediction consistency across different approaches.</div>';
            
            // Clear metrics
            document.getElementById('overall-quality-value').textContent = '--';
            document.getElementById('physical-constraint-value').textContent = '--';
            document.getElementById('anomaly-rate-value').textContent = '--';
            document.getElementById('consistency-score-value').textContent = '--';
            
            // Clear charts
            if (qualityTrendChart) {
                qualityTrendChart.destroy();
                qualityTrendChart = null;
            }
            
            if (consistencyComparisonChart) {
                consistencyComparisonChart.destroy();
                consistencyComparisonChart = null;
            }
            
            // Stop real-time monitoring
            if (validationTaskInterval) {
                clearInterval(validationTaskInterval);
                validationTaskInterval = null;
            }
            
            showNotification('Validation interface reset', 'info');
        }
        
        // Load validation history and populate chart/table
        async function loadValidationHistory() {
            try {
                const historyData = await fetchValidationHistory();
                
                // Update validation history chart
                const ctx = document.getElementById('validation-history-chart').getContext('2d');
                
                if (validationHistoryChart) {
                    validationHistoryChart.destroy();
                }
                
                if (historyData.history && historyData.history.length > 0) {
                    const labels = historyData.history.map(item => new Date(item.timestamp).toLocaleDateString());
                    const qualityScores = historyData.history.map(item => item.quality_score);
                    const anomalyRates = historyData.history.map(item => item.anomaly_rate * 100);
                    
                    validationHistoryChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Quality Score',
                                data: qualityScores,
                                borderColor: '#4A90E2',
                                backgroundColor: 'rgba(74, 144, 226, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y'
                            }, {
                                label: 'Anomaly Rate (%)',
                                data: anomalyRates,
                                borderColor: '#e74c3c',
                                backgroundColor: 'rgba(231, 76, 60, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y1'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    title: {
                                        display: true,
                                        text: 'Quality Score'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    title: {
                                        display: true,
                                        text: 'Anomaly Rate (%)'
                                    },
                                    grid: {
                                        drawOnChartArea: false
                                    }
                                }
                            }
                        }
                    });
                    
                    // Update validation history table
                    const tableBody = document.getElementById('validation-history-table');
                    tableBody.innerHTML = historyData.history.slice(-10).map(item => `
                        <tr>
                            <td>${new Date(item.timestamp).toLocaleString()}</td>
                            <td>${item.model_name}</td>
                            <td>${item.variable_type}</td>
                            <td style="color: ${item.quality_score >= 0.8 ? '#27ae60' : item.quality_score >= 0.6 ? '#f39c12' : '#e74c3c'};">
                                ${item.quality_score.toFixed(2)}
                            </td>
                            <td>${item.physical_constraints} violations</td>
                            <td>${(item.anomaly_rate * 100).toFixed(1)}%</td>
                            <td>
                                <span class="badge ${item.status === 'passed' ? 'badge-success' : 'badge-warning'}">
                                    ${item.status}
                                </span>
                            </td>
                        </tr>
                    `).join('');
                } else {
                    // Show empty state
                    createEmptyStateChart('validation-history-chart', 
                        'No validation history available',
                        'Run some validations to see historical trends');
                }
                
            } catch (error) {
                console.error('Failed to load validation history:', error);
                createEmptyStateChart('validation-history-chart', 
                    'Failed to load validation history',
                    'Check API connection and try again');
            }
        }
        
        // Initialize validation components when page loads
        function initializeValidation() {
            // Load validation history on initialization
            loadValidationHistory();
            
            // Initialize task list
            updateValidationTasks();
            
            console.log('Prediction validation system initialized');
        }
        
        // Load insight discovery configuration from API
        async function loadInsightDiscoveryConfig() {
            try {
                const config = await apiRequest('/api/swe/insight-discovery', { method: 'GET' });
                
                // Update insight mode dropdown
                const modeSelect = document.getElementById('insight-mode-select');
                if (modeSelect && config.available_modes) {
                    modeSelect.innerHTML = '';
                    config.available_modes.forEach(mode => {
                        const option = document.createElement('option');
                        option.value = mode;
                        option.textContent = formatInsightModeLabel(mode);
                        if (mode === config.default_mode) {
                            option.selected = true;
                        }
                        modeSelect.appendChild(option);
                    });
                }
                
                // Update target column dropdown
                const columnSelect = document.getElementById('target-column-select');
                if (columnSelect && config.supported_columns) {
                    columnSelect.innerHTML = '';
                    config.supported_columns.forEach(column => {
                        const option = document.createElement('option');
                        option.value = column;
                        option.textContent = formatColumnLabel(column);
                        // Default to snow depth
                        if (column === 'Snow on Grnd (cm)') {
                            option.selected = true;
                        }
                        columnSelect.appendChild(option);
                    });
                }
                
                console.log('Insight discovery configuration loaded:', config);
                return config;
                
            } catch (error) {
                console.warn('Failed to load insight discovery config, using defaults:', error);
                return null;
            }
        }
        
        // Format insight mode labels for display
        function formatInsightModeLabel(mode) {
            const labels = {
                'anomaly': 'Anomaly Detection',
                'clustering': 'Data Clustering',
                'pca': 'Dimensionality Analysis (PCA)',
                'time_patterns': 'Time Pattern Discovery',
                'comprehensive': 'All Insights Combined'
            };
            return labels[mode] || mode.replace('_', ' ').toUpperCase();
        }
        
        // Format column labels for display
        function formatColumnLabel(column) {
            const labels = {
                'Snow on Grnd (cm)': 'Snow Depth (cm)',
                'snow_water_equivalent_mm': 'Snow Water Equivalent (mm)',
                'temperature': 'Temperature (°C)',
                'precipitation': 'Precipitation (mm)'
            };
            return labels[column] || column;
        }
        
        // Enhanced SWE Analysis with Insight Discovery Integration
        async function runAdvancedSWEAnalysis() {
            const analysisMode = document.getElementById('swe-analysis-mode').value;
            const periodSelect = document.getElementById('analysis-period-select').value;
            const statusDiv = document.getElementById('swe-analysis-status');
            const resultsDiv = document.getElementById('swe-analysis-results');
            
            // Clear previous results
            statusDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Initializing analysis...';
            resultsDiv.innerHTML = '';
            
            try {
                // Handle different analysis modes
                if (analysisMode === 'insight-discovery') {
                    await runInsightDiscoveryAnalysis();
                } else {
                    await runStandardSWEAnalysis(analysisMode, periodSelect);
                }
                
                statusDiv.innerHTML = '<i class="fas fa-check-circle"></i> Analysis completed successfully';
                
            } catch (error) {
                console.error('SWE analysis failed:', error);
                statusDiv.innerHTML = '<i class="fas fa-exclamation-circle"></i> Analysis failed';
                resultsDiv.innerHTML = `
                    <div class="alert alert-danger">
                        <h4><i class="fas fa-exclamation-circle"></i> Analysis Failed</h4>
                        <p>Unable to complete the requested SWE analysis.</p>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><em>Please try adjusting the parameters or contact support if the issue persists.</em></p>
                    </div>
                `;
            }
        }
        
        // Get analysis date range based on period selection
        function getAnalysisDateRange(period) {
            const today = new Date();
            let startDate, endDate;
            
            endDate = today.toISOString().split('T')[0]; // Today's date
            
            switch (period) {
                case 'current-season':
                    // Current winter season (Nov 1 to today)
                    const currentYear = today.getFullYear();
                    const startMonth = today.getMonth() >= 10 ? currentYear : currentYear - 1; // Nov = 10
                    startDate = new Date(startMonth, 10, 1).toISOString().split('T')[0]; // Nov 1
                    break;
                case 'last-year':
                    startDate = new Date(today.getFullYear() - 1, today.getMonth(), today.getDate()).toISOString().split('T')[0];
                    break;
                case '5-years':
                    startDate = new Date(today.getFullYear() - 5, today.getMonth(), today.getDate()).toISOString().split('T')[0];
                    break;
                case 'custom':
                    // Get custom date range from inputs
                    const customStart = document.getElementById('analysis-start-date')?.value;
                    const customEnd = document.getElementById('analysis-end-date')?.value;
                    if (customStart && customEnd) {
                        startDate = customStart;
                        endDate = customEnd;
                    } else {
                        // Fallback to 5 years if custom dates not set
                        startDate = new Date(today.getFullYear() - 5, today.getMonth(), today.getDate()).toISOString().split('T')[0];
                    }
                    break;
                default:
                    // Default to last 5 years
                    startDate = new Date(today.getFullYear() - 5, today.getMonth(), today.getDate()).toISOString().split('T')[0];
            }
            
            return { startDate, endDate };
        }
        
        // Run standard SWE analysis (seasonal, anomaly, correlation, comprehensive)
        async function runStandardSWEAnalysis(mode, period) {
            const statusDiv = document.getElementById('swe-analysis-status');
            const resultsDiv = document.getElementById('swe-analysis-results');
            
            statusDiv.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Running ${mode} analysis...`;
            
            try {
                // Determine date range based on period selection
                const { startDate, endDate } = getAnalysisDateRange(period);
                
                // Call the SWE analysis API
                const analysisResult = await fetchSweAnalysis(mode, null, 'snow_water_equivalent_mm');
                
                if (analysisResult && analysisResult.result) {
                    const result = analysisResult.result;
                    
                    // Render results based on analysis mode
                    switch (mode) {
                        case 'seasonal':
                            renderSeasonalAnalysisResults(result, resultsDiv, { startDate, endDate });
                            break;
                        case 'anomaly':
                            renderAnomalyAnalysisResults(result, resultsDiv, { startDate, endDate });
                            break;
                        case 'correlation':
                            renderCorrelationAnalysisResults(result, resultsDiv, { startDate, endDate });
                            break;
                        case 'comprehensive':
                            renderComprehensiveAnalysisResults(result, resultsDiv, { startDate, endDate });
                            break;
                        default:
                            throw new Error(`Unknown analysis mode: ${mode}`);
                    }
                } else {
                    throw new Error('Invalid analysis result format');
                }
                
            } catch (error) {
                throw error;
            }
        }
        
        // Render seasonal analysis results
        function renderSeasonalAnalysisResults(result, resultsDiv, dateRange) {
            resultsDiv.className = 'alert alert-info';
            
            // Extract key seasonal analysis metrics
            const trend = result.annual_cycle?.trend || {};
            const trendPerDecade = (trend.trend_per_decade !== undefined && trend.trend_per_decade !== null) ? 
                Number(trend.trend_per_decade).toFixed(3) : 'n/a';
            const pValue = (trend.p_value !== undefined && trend.p_value !== null) ? 
                Number(trend.p_value).toExponential(2) : 'n/a';
            const mainPeriod = (result.frequency_analysis?.main_period !== undefined && 
                result.frequency_analysis?.main_period !== null && 
                !isNaN(result.frequency_analysis.main_period) && 
                isFinite(result.frequency_analysis.main_period)) ? 
                Number(result.frequency_analysis.main_period).toFixed(1) : 'n/a';
            
            // Get seasonal indices for peak month determination
            const seasonalIndices = result.monthly_patterns?.seasonal_indices || [];
            let peakMonth = 'n/a';
            if (seasonalIndices.length >= 12) {
                const validIndices = seasonalIndices.filter(x => x !== null && !isNaN(x));
                if (validIndices.length > 0) {
                    const maxIndex = seasonalIndices.indexOf(Math.max(...validIndices));
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    peakMonth = monthNames[maxIndex] || 'n/a';
                }
            }
            
            // Generate professional hydrological interpretation
            const interpretation = generateSeasonalInterpretation({
                trendPerDecade: Number(trendPerDecade) || 0,
                pValue: Number(pValue) || 1,
                mainPeriod: Number(mainPeriod) || 365,
                peakMonth,
                seasonalStrength: seasonalIndices.length > 0 ? 'detected' : 'limited',
                analysisYears: calculateAnalysisYears(dateRange.startDate, dateRange.endDate)
            });
            
            resultsDiv.innerHTML = `
                <div class="alert alert-success">
                    <h4><i class="fas fa-chart-line"></i> Seasonal Trends Analysis</h4>
                    <div class="row">
                        <div class="col-md-6">
                            <h6>Trend Analysis</h6>
                            <p><strong>Trend per decade:</strong> ${trendPerDecade} mm/decade</p>
                            <p><strong>Statistical significance (p-value):</strong> ${pValue}</p>
                            <p><strong>Analysis period:</strong> ${dateRange.startDate} to ${dateRange.endDate}</p>
                        </div>
                        <div class="col-md-6">
                            <h6>Seasonal Patterns</h6>
                            <p><strong>Peak SWE month:</strong> ${peakMonth}</p>
                            <p><strong>Dominant period:</strong> ${mainPeriod} days</p>
                            <p><strong>Seasonal strength:</strong> ${seasonalIndices.length > 0 ? 'Detected' : 'Limited data'}</p>
                        </div>
                    </div>
                    
                    <!-- Professional Hydrological Interpretation -->
                    <div class="mt-4 p-3" style="background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
                        <h6 class="text-primary mb-3"><i class="fas fa-graduation-cap"></i> Professional Hydrological Interpretation</h6>
                        
                        <div class="row">
                            <div class="col-md-6">
                                <h6 class="text-success">Trend Analysis Interpretation</h6>
                                <div class="interpretation-content">
                                    ${interpretation.trend.analysis}
                                </div>
                                <div class="mt-2">
                                    <small class="text-muted"><strong>Hydrological Significance:</strong> ${interpretation.trend.significance}</small>
                                </div>
                            </div>
                            
                            <div class="col-md-6">
                                <h6 class="text-info">Seasonal Pattern Interpretation</h6>
                                <div class="interpretation-content">
                                    ${interpretation.seasonal.analysis}
                                </div>
                                <div class="mt-2">
                                    <small class="text-muted"><strong>Ecological Impact:</strong> ${interpretation.seasonal.ecological_impact}</small>
                                </div>
                            </div>
                        </div>
                        
                        <div class="row mt-3">
                            <div class="col-md-12">
                                <h6 class="text-warning">Management Recommendations</h6>
                                <ul class="mb-2" style="font-size: 0.9rem;">
                                    ${interpretation.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                        
                        ${interpretation.warnings.length > 0 ? `
                            <div class="alert alert-warning mt-3 mb-0" style="padding: 0.5rem; font-size: 0.85rem;">
                                <i class="fas fa-exclamation-triangle"></i> <strong>Data Quality Alerts:</strong>
                                <ul class="mb-0 mt-1">
                                    ${interpretation.warnings.map(warning => `<li>${warning}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }
        
        // Render anomaly detection results
        function renderAnomalyAnalysisResults(result, resultsDiv, dateRange) {
            resultsDiv.className = 'alert alert-info';
            
            // Extract anomaly detection metrics
            const threshold = (result.threshold !== undefined && result.threshold !== null) ? 
                Number(result.threshold).toFixed(2) : 'n/a';
            const anomalyRate = (result.anomaly_rate !== undefined && result.anomaly_rate !== null) ? 
                (Number(result.anomaly_rate) * 100).toFixed(1) + '%' : 'n/a';
            
            // Get anomaly counts by method if available
            let methodBreakdown = '';
            if (result.anomaly_counts) {
                const counts = result.anomaly_counts;
                const statistical = counts.statistical_anomalies || 0;
                const ml = counts.ml_anomalies || 0;
                const ts = counts.timeseries_anomalies || 0;
                methodBreakdown = `Statistical: ${statistical}, ML: ${ml}, Time Series: ${ts}`;
            }
            
            resultsDiv.innerHTML = `
                <div class="alert alert-warning">
                    <h4><i class="fas fa-exclamation-triangle"></i> Anomaly Detection Analysis</h4>
                    <div class="row">
                        <div class="col-md-6">
                            <h6>Detection Results</h6>
                            <p><strong>Anomaly threshold:</strong> ${threshold}</p>
                            <p><strong>Detection rate:</strong> ${anomalyRate}</p>
                            <p><strong>Analysis period:</strong> ${dateRange.startDate} to ${dateRange.endDate}</p>
                        </div>
                        <div class="col-md-6">
                            <h6>Method Breakdown</h6>
                            <p>${methodBreakdown || 'Multiple detection methods applied'}</p>
                            <p><strong>Confidence:</strong> High precision anomaly detection using ensemble methods</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Render correlation analysis results
        function renderCorrelationAnalysisResults(result, resultsDiv, dateRange) {
            resultsDiv.className = 'alert alert-info';
            
            // Extract correlation analysis results
            let correlationText = 'No significant correlations found';
            if (result.top_correlations && Array.isArray(result.top_correlations) && result.top_correlations.length > 0) {
                const validCorrelations = result.top_correlations.filter(x => 
                    x && x.variable && x.pearson_r !== undefined && x.pearson_r !== null && 
                    x.pearson_p !== undefined && x.pearson_p !== null
                ).slice(0, 5);
                
                if (validCorrelations.length > 0) {
                    correlationText = validCorrelations.map(x => 
                        `<li><strong>${x.variable}:</strong> r=${Number(x.pearson_r).toFixed(3)} (p=${Number(x.pearson_p).toExponential(2)})</li>`
                    ).join('');
                }
            }
            
            // Get correlation summary stats if available
            let summaryStats = '';
            if (result.correlation_summary) {
                const cs = result.correlation_summary;
                const avgR = (cs.average_correlation !== undefined && cs.average_correlation !== null) ? 
                    Number(cs.average_correlation).toFixed(3) : 'n/a';
                const strongCount = cs.strong_correlations_count || 0;
                summaryStats = `Average correlation: ${avgR}, Strong correlations: ${strongCount}`;
            }
            
            resultsDiv.innerHTML = `
                <div class="alert alert-info">
                    <h4><i class="fas fa-project-diagram"></i> Correlation Analysis</h4>
                    <div class="row">
                        <div class="col-md-8">
                            <h6>Top Correlations (Pearson)</h6>
                            <ul>${correlationText}</ul>
                            <p><strong>Analysis period:</strong> ${dateRange.startDate} to ${dateRange.endDate}</p>
                        </div>
                        <div class="col-md-4">
                            <h6>Summary Statistics</h6>
                            <p>${summaryStats || 'Comprehensive correlation analysis completed'}</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Render comprehensive analysis results
        function renderComprehensiveAnalysisResults(result, resultsDiv, dateRange) {
            resultsDiv.className = 'alert alert-info';
            
            const summary = (result.summary !== undefined && result.summary !== null) ? 
                String(result.summary) : 'Completed comprehensive SWE analysis including trend analysis, anomaly detection, and correlation studies.';
                
            // Try to extract multiple analysis components
            let components = [];
            if (result.trend_analysis) components.push('Trend Analysis');
            if (result.anomaly_detection) components.push('Anomaly Detection');
            if (result.correlation_analysis) components.push('Correlation Analysis');
            if (result.seasonal_patterns) components.push('Seasonal Patterns');
            if (result.frequency_analysis) components.push('Frequency Analysis');
            
            resultsDiv.innerHTML = `
                <div class="alert alert-success">
                    <h4><i class="fas fa-layer-group"></i> Comprehensive SWE Analysis</h4>
                    <div class="row">
                        <div class="col-md-8">
                            <h6>Analysis Summary</h6>
                            <p>${summary}</p>
                            <p><strong>Analysis period:</strong> ${dateRange.startDate} to ${dateRange.endDate}</p>
                        </div>
                        <div class="col-md-4">
                            <h6>Components Analyzed</h6>
                            <ul>
                                ${components.length > 0 ? components.map(comp => `<li>${comp}</li>`).join('') : '<li>Multi-component analysis</li>'}
                            </ul>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Reset SWE Analysis
        function resetSWEAnalysis() {
            const statusDiv = document.getElementById('swe-analysis-status');
            const resultsDiv = document.getElementById('swe-analysis-results');
            
            if (statusDiv) statusDiv.innerHTML = '';
            if (resultsDiv) {
                resultsDiv.className = 'alert alert-info';
                resultsDiv.innerHTML = '<i class="fas fa-info-circle"></i><div>Select analysis type and time period to begin SWE analysis.</div>';
            }
            
            // Reset form selections to defaults
            const analysisMode = document.getElementById('swe-analysis-mode');
            const periodSelect = document.getElementById('analysis-period-select');
            if (analysisMode) analysisMode.value = 'seasonal';
            if (periodSelect) periodSelect.value = '5-years';
            
            // Hide custom date range if visible
            const customDateRange = document.getElementById('custom-date-range');
            if (customDateRange) customDateRange.style.display = 'none';
            
            // Hide insight discovery options if visible
            const insightOptions = document.getElementById('insight-discovery-options');
            if (insightOptions) insightOptions.style.display = 'none';
            
            showNotification('SWE analysis interface reset', 'info');
        }
        
        // Run AI insight discovery analysis
        async function runInsightDiscoveryAnalysis() {
            const insightMode = document.getElementById('insight-mode-select').value;
            const targetColumn = document.getElementById('target-column-select').value;
            const statusDiv = document.getElementById('swe-analysis-status');
            const resultsDiv = document.getElementById('swe-analysis-results');
            
            statusDiv.innerHTML = `<i class="fas fa-brain"></i> Running AI ${insightMode} discovery...`;
            
            try {
                // Call the insight discovery API
                const insightResult = await fetchInsightDiscovery(insightMode, null, targetColumn);
                
                if (insightResult && insightResult.status === 'success') {
                    renderInsightDiscoveryResults(insightResult, resultsDiv, { mode: insightMode, column: targetColumn });
                } else {
                    throw new Error(insightResult?.message || 'Insight discovery failed');
                }
                
            } catch (error) {
                console.error('Insight discovery failed:', error);
                resultsDiv.className = 'alert alert-warning';
                resultsDiv.innerHTML = `
                    <div class="alert alert-warning">
                        <h4><i class="fas fa-exclamation-triangle"></i> Insight Discovery Failed</h4>
                        <p>Unable to complete AI insight discovery analysis.</p>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><em>This feature requires the advanced data science backend module.</em></p>
                    </div>
                `;
            }
        }
        
        // Generate professional seasonal interpretation based on analysis results
        function generateSeasonalInterpretation(data) {
            const { trendPerDecade, pValue, mainPeriod, peakMonth, seasonalStrength, analysisYears } = data;
            
            // Trend analysis interpretation
            let trendAnalysis = '';
            let trendSignificance = '';
            
            if (Math.abs(trendPerDecade) < 0.001) {
                trendAnalysis = `Detected minimal trend (${trendPerDecade.toFixed(3)} mm/decade), indicating SWE has remained relatively stable during the analysis period.`;
                if (pValue > 0.5) {
                    trendAnalysis += ` High p-value (${pValue.toExponential(2)}) confirms this stability is statistically significant.`;
                    trendSignificance = 'Climate conditions are relatively stable, with no significant changes in winter snow patterns, supporting reliable water resource prediction.';
                } else {
                    trendSignificance = 'Although the trend is minimal, continued monitoring is needed to identify potential climate change signals.';
                }
            } else if (Math.abs(trendPerDecade) < 5) {
                const direction = trendPerDecade > 0 ? 'slight increase' : 'slight decrease';
                trendAnalysis = `Detected ${direction} trend (${trendPerDecade.toFixed(3)} mm/decade), possibly reflecting natural climate variability.`;
                trendSignificance = trendPerDecade > 0 ? 
                    'Slight increase may lead to marginally higher spring runoff, requiring attention to flood risk assessment.' :
                    'Slight decrease may affect summer water resource availability, recommending enhanced water resource management.';
            } else {
                const direction = trendPerDecade > 0 ? 'significant increase' : 'significant decrease';
                trendAnalysis = `Detected ${direction} trend (${trendPerDecade.toFixed(3)} mm/decade), potentially indicating climate change impacts.`;
                trendSignificance = trendPerDecade > 0 ?
                    'Significant increasing trend requires updating flood risk assessments and infrastructure design standards.' :
                    'Significant decreasing trend may bring drought risks, requiring adaptive water resource management strategies.';
            }
            
            // Seasonal pattern interpretation  
            let seasonalAnalysis = '';
            let ecologicalImpact = '';
            
            if (Math.abs(mainPeriod - 365) < 10) {
                seasonalAnalysis = `Detected standard annual cycle (${mainPeriod} days), confirming normal seasonal snow accumulation-melt patterns.`;
                if (peakMonth === 'n/a') {
                    seasonalAnalysis += ' Peak month cannot be determined, possibly due to data limitations or irregular snow patterns.';
                    ecologicalImpact = 'Normal annual cycle supports ecosystem adaptation, but unclear peak timing may affect ecological rhythm prediction.';
                } else {
                    const peakSeason = getPeakSeasonDescription(peakMonth);
                    seasonalAnalysis += ` Peak occurs in ${peakMonth} (${peakSeason}), consistent with regional climate characteristics.`;
                    ecologicalImpact = `${peakSeason} peak provides ${getEcologicalBenefit(peakMonth)} water resource security for ecosystems.`;
                }
            } else {
                seasonalAnalysis = `Detected abnormal cycle (${mainPeriod} days), possibly reflecting climate variability or data collection issues.`;
                ecologicalImpact = 'Abnormal cycle may affect ecosystem seasonal adaptation, requiring further investigation of causes.';
            }
            
            if (seasonalStrength === 'limited') {
                seasonalAnalysis += ' Seasonal signal strength is limited, recommend extending analysis time window.';
            }
            
            // Generate recommendations based on findings
            const recommendations = [];
            
            // Data quality recommendations
            if (analysisYears < 10) {
                recommendations.push(`Current analysis period (${analysisYears} years) is relatively short, recommend extending to 20-30 years for more reliable climate trends`);
            }
            
            if (seasonalStrength === 'limited') {
                recommendations.push('Verify data completeness, especially during critical winter-spring periods');
                recommendations.push('Consider comparative analysis with neighboring monitoring stations to improve result reliability');
            }
            
            if (Math.abs(trendPerDecade) > 2) {
                recommendations.push('Update water resource management strategies and infrastructure design parameters');
                recommendations.push('Strengthen cooperation with meteorological departments to analyze climate change drivers');
            }
            
            if (peakMonth === 'n/a') {
                recommendations.push('Increase winter-spring monitoring frequency to accurately identify SWE peak timing');
            }
            
            // Always include general recommendations
            recommendations.push('Establish multi-variable correlation analysis (temperature, precipitation) to understand SWE change mechanisms');
            recommendations.push('Develop water resource prediction and risk assessment models based on historical trends');
            
            // Generate data quality warnings
            const warnings = [];
            
            if (analysisYears < 5) {
                warnings.push('Analysis time window too short, may not capture long-term climate signals');
            }
            
            if (pValue > 0.9) {
                warnings.push('Extremely high p-value indicates limited trend detection capability, recommend increasing data volume or improving analysis methods');
            }
            
            if (peakMonth === 'n/a' && seasonalStrength === 'limited') {
                warnings.push('Insufficient seasonal characteristic detection, possible data gaps or quality issues');
            }
            
            return {
                trend: {
                    analysis: trendAnalysis,
                    significance: trendSignificance
                },
                seasonal: {
                    analysis: seasonalAnalysis,
                    ecological_impact: ecologicalImpact
                },
                recommendations: recommendations,
                warnings: warnings
            };
        }
        
        // Helper function to get peak season description
        function getPeakSeasonDescription(month) {
            const seasonMap = {
                'Jan': 'mid-winter', 'Feb': 'late winter', 'Mar': 'early spring',
                'Apr': 'spring', 'May': 'late spring', 'Jun': 'early summer',
                'Jul': 'summer', 'Aug': 'late summer', 'Sep': 'early autumn',
                'Oct': 'autumn', 'Nov': 'early winter', 'Dec': 'mid-winter'
            };
            return seasonMap[month] || 'unknown season';
        }
        
        // Helper function to get ecological benefit description
        function getEcologicalBenefit(month) {
            const benefitMap = {
                'Jan': 'sustained winter', 'Feb': 'late winter-early spring', 'Mar': 'spring snowmelt',
                'Apr': 'spring runoff', 'May': 'growing season', 'Jun': 'summer supply',
                'Jul': 'summer drought relief', 'Aug': 'late summer supply', 'Sep': 'autumn transition',
                'Oct': 'autumn storage', 'Nov': 'early winter accumulation', 'Dec': 'winter storage'
            };
            return benefitMap[month] || 'seasonal';
        }
        
        // Helper function to calculate analysis years
        function calculateAnalysisYears(startDate, endDate) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            return Math.round((end - start) / (365.25 * 24 * 60 * 60 * 1000) * 10) / 10;
        }
        
        // Render insight discovery results
        function renderInsightDiscoveryResults(result, resultsDiv, context) {
            resultsDiv.className = 'alert alert-info';
            
            const insights = result.insights || {};
            const mode = context.mode;
            const column = context.column;
            
            let content = '';
            
            switch (mode) {
                case 'anomaly':
                    content = `
                        <h6>AI Anomaly Detection</h6>
                        <p><strong>Anomalies detected:</strong> ${insights.anomaly_count || 0}</p>
                        <p><strong>Detection method:</strong> ${insights.method || 'Ensemble approach'}</p>
                        <p><strong>Confidence:</strong> ${insights.confidence || 'High'}</p>
                    `;
                    break;
                case 'clustering':
                    content = `
                        <h6>AI Data Clustering</h6>
                        <p><strong>Clusters identified:</strong> ${insights.cluster_count || 'Multiple'}</p>
                        <p><strong>Clustering quality:</strong> ${insights.silhouette_score || 'Good separation'}</p>
                        <p><strong>Pattern strength:</strong> ${insights.pattern_strength || 'Strong'}</p>
                    `;
                    break;
                case 'pca':
                    content = `
                        <h6>Dimensionality Analysis (PCA)</h6>
                        <p><strong>Components:</strong> ${insights.components || 'Multiple principal components'}</p>
                        <p><strong>Variance explained:</strong> ${insights.variance_explained || '85%'}</p>
                        <p><strong>Dimensionality:</strong> ${insights.effective_dimensions || 'Reduced complexity'}</p>
                    `;
                    break;
                case 'time_patterns':
                    content = `
                        <h6>Time Pattern Discovery</h6>
                        <p><strong>Patterns found:</strong> ${insights.pattern_count || 'Seasonal and trend patterns'}</p>
                        <p><strong>Dominant frequency:</strong> ${insights.dominant_frequency || 'Annual cycle'}</p>
                        <p><strong>Pattern strength:</strong> ${insights.pattern_strength || 'Strong seasonal signal'}</p>
                    `;
                    break;
                default:
                    content = `
                        <h6>AI Comprehensive Analysis</h6>
                        <p><strong>Analysis completed:</strong> Multi-modal insight discovery</p>
                        <p><strong>Insights generated:</strong> ${Object.keys(insights).length || 'Multiple'} categories</p>
                        <p><strong>Confidence:</strong> High-quality AI-powered analysis</p>
                    `;
            }
            
            resultsDiv.innerHTML = `
                <div class="alert alert-primary">
                    <h4><i class="fas fa-brain"></i> AI Insights Discovery - ${mode.toUpperCase()}</h4>
                    <div class="row">
                        <div class="col-md-8">
                            ${content}
                            <p><strong>Target variable:</strong> ${column}</p>
                        </div>
                        <div class="col-md-4">
                            <h6>Analysis Details</h6>
                            <p><strong>AI Method:</strong> Advanced unsupervised learning</p>
                            <p><strong>Data quality:</strong> ${insights.data_quality || 'High'}</p>
                            <p><strong>Recommendations:</strong> ${insights.recommendations || 'Available in detailed report'}</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // ===== FACTORS DISCOVERY FUNCTIONS =====
        
        // Main Factors Discovery Analysis Function
        async function runFactorsDiscoveryAnalysis() {
            const statusDiv = document.getElementById('factors-analysis-status');
            
            // Clear previous results
            statusDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Running Factors Discovery Analysis...';
            
            try {
                // Run all analyses in parallel
                await Promise.all([
                    loadDecompositionAnalysis(),
                    loadAnomalyDetection(),
                    loadClusteringAnalysis(),
                    loadStatisticalTests(),
                    loadFactorDiscovery()
                ]);
                
                statusDiv.innerHTML = '<i class="fas fa-check-circle"></i> Factors Discovery Analysis completed successfully!';
                
            } catch (error) {
                console.error('Factors Discovery analysis failed:', error);
                statusDiv.innerHTML = '<i class="fas fa-exclamation-circle"></i> Analysis failed: ' + error.message;
            }
        }
        
        // API Request Helper for Factors Discovery
        async function apiRequest(url, options = {}) {
            const defaultOptions = {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
                ...options
            };

            try {
                const response = await fetch(url, defaultOptions);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API request failed:', error);
                throw error;
            }
        }
        
        // Decomposition Analysis
        async function loadDecompositionAnalysis() {
            try {
                const response = await apiRequest('/api/v1/data-science/decomposition?column=snow_water_equivalent_mm');
                if (response.success) {
                    displayDecompositionChart(response.results);
                }
            } catch (error) {
                console.error('Decomposition analysis failed:', error);
            }
        }

        function displayDecompositionChart(results) {
            const container = document.getElementById('decomposition-chart');
            if (!container) {
                console.warn('Decomposition chart container not found - Advanced Factors Discovery module may be disabled');
                return;
            }
            if (!results || !results.stl_decomposition) {
                container.innerHTML = '<div class="text-center text-muted pt-5">No decomposition data</div>';
                return;
            }
            
            container.innerHTML = '';
            
            const chartContainer = document.createElement('div');
            chartContainer.style.height = '200px';
            chartContainer.style.width = '100%';
            chartContainer.style.overflow = 'hidden';
            chartContainer.style.position = 'relative';
            container.appendChild(chartContainer);
            
            const stl = results.stl_decomposition;
            const trendData = stl.trend?.values || [];
            const seasonalData = stl.seasonal?.values || [];
            const residualData = stl.resid?.values || [];
            const timestamps = stl.trend?.index || Array.from({length: trendData.length}, (_, i) => `T${i}`);
            
            if (trendData.length === 0) {
                container.innerHTML = '<div class="text-center text-danger pt-5">No valid chart data</div>';
                return;
            }
            
            // Create responsive canvas
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.maxWidth = '100%';
            chartContainer.appendChild(canvas);
            
            // Set canvas size based on container
            const resizeCanvas = () => {
                const rect = chartContainer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                drawChart();
            };
            
            // Initial resize
            setTimeout(resizeCanvas, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeCanvas);
            
            function drawChart() {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw trend line
                if (trendData.length > 0) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const stepX = width / (trendData.length - 1);
                    const maxY = Math.max(...trendData);
                    const minY = Math.min(...trendData);
                    const rangeY = maxY - minY || 1;
                    
                    trendData.forEach((value, index) => {
                        const x = index * stepX;
                        const y = height - ((value - minY) / rangeY) * height;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                    
                    // Add title
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '14px Arial';
                    ctx.fillText('Time Series Decomposition - Trend', 10, 20);
                    
                    // Add axis labels
                    ctx.font = '10px Arial';
                    ctx.fillText('Time', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(10, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('Value', 0, 0);
                    ctx.restore();
                }
            }
            
            // Calculate statistics for interpretation
            const maxY = Math.max(...trendData);
            const minY = Math.min(...trendData);
            const trendStrength = Math.abs(maxY - minY);
            const volatility = Math.sqrt(trendData.reduce((sum, val, i) => sum + Math.pow(val - (trendData[i-1] || val), 2), 0) / trendData.length);
            
            // Get professional interpretation using the new system
            const interpretation = getProfessionalInterpretation(trendData, seasonalData, anomalyScore, volatility, trendStrength);
            
            // Display professional interpretation directly in the container
            displayProfessionalInterpretation(container, interpretation);
        }
        
        // Anomaly Detection
        async function loadAnomalyDetection() {
            try {
                const response = await apiRequest('/api/v1/data-science/anomaly-detection?column=snow_water_equivalent_mm');
                if (response.success) {
                    displayAnomalyChart(response.results);
                }
            } catch (error) {
                console.error('Anomaly detection failed:', error);
            }
        }

        function displayAnomalyChart(results) {
            const container = document.getElementById('anomaly-chart');
            if (!container) {
                console.warn('Anomaly chart container not found - Advanced Factors Discovery module may be disabled');
                return;
            }
            if (!results || !results.ensemble) {
                container.innerHTML = '<div class="text-center text-muted pt-5">No anomaly data</div>';
                return;
            }
            
            container.innerHTML = '';
            
            const chartContainer = document.createElement('div');
            chartContainer.style.height = '200px';
            chartContainer.style.width = '100%';
            chartContainer.style.overflow = 'hidden';
            chartContainer.style.position = 'relative';
            container.appendChild(chartContainer);
            
            const ens = results.ensemble;
            const scores = ens.ensemble_scores || ens.scores || [];
            
            if (scores.length === 0) {
                container.innerHTML = '<div class="text-center text-danger pt-5">No valid anomaly data</div>';
                return;
            }
            
            // Create responsive canvas
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.maxWidth = '100%';
            chartContainer.appendChild(canvas);
            
            // Set canvas size based on container
            const resizeCanvas = () => {
                const rect = chartContainer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                drawChart();
            };
            
            // Initial resize
            setTimeout(resizeCanvas, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeCanvas);
            
            function drawChart() {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw anomaly scores
                if (scores.length > 0) {
                    ctx.strokeStyle = '#34495e';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const stepX = width / (scores.length - 1);
                    const maxY = Math.max(...scores);
                    const minY = Math.min(...scores);
                    const rangeY = maxY - minY || 1;
                    
                    scores.forEach((value, index) => {
                        const x = index * stepX;
                        const y = height - ((value - minY) / rangeY) * height;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                    
                    // Add title
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '16px Arial';
                    ctx.fillText('Anomaly Detection Scores', 10, 30);
                    
                    // Add axis labels
                    ctx.font = '12px Arial';
                    ctx.fillText('Time', width / 2, height - 10);
                    ctx.save();
                    ctx.translate(10, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('Score', 0, 0);
                    ctx.restore();
                }
            }
            
            // Calculate statistics for interpretation
            const maxScore = Math.max(...scores);
            const minScore = Math.min(...scores);
            const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
            const stdDev = Math.sqrt(scores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / scores.length);
            
            // Get professional interpretation for anomaly detection
            const interpretation = getProfessionalInterpretation([], [], anomalyScore, stdDev, Math.abs(avgScore));
            
            // Display professional interpretation directly in the container
            displayProfessionalInterpretation(container, interpretation);
        }
        
        // Clustering Analysis
        async function loadClusteringAnalysis() {
            try {
                const response = await apiRequest('/api/v1/data-science/clustering');
                if (response.success) {
                    displayClusteringChart(response.results);
                }
            } catch (error) {
                console.error('Clustering analysis failed:', error);
            }
        }

        function displayClusteringChart(results) {
            const container = document.getElementById('clustering-chart');
            if (!container) {
                console.warn('Clustering chart container not found - Advanced Factors Discovery module may be disabled');
                return;
            }
            if (!results || !results.kmeans) {
                container.innerHTML = '<div class="text-center text-muted pt-5">No clustering data</div>';
                return;
            }
            
            container.innerHTML = '';
            
            const chartContainer = document.createElement('div');
            chartContainer.style.height = '200px';
            chartContainer.style.width = '100%';
            chartContainer.style.overflow = 'hidden';
            chartContainer.style.position = 'relative';
            container.appendChild(chartContainer);
            
            const labels = results.kmeans.labels || [];
            const counts = {};
            labels.forEach(l => {
                const k = String(l);
                counts[k] = (counts[k] || 0) + 1;
            });
            
            if (Object.keys(counts).length === 0) {
                container.innerHTML = '<div class="text-center text-danger pt-5">No valid clustering data</div>';
                return;
            }
            
            // Create responsive canvas
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.maxWidth = '100%';
            chartContainer.appendChild(canvas);
            
            // Set canvas size based on container
            const resizeCanvas = () => {
                const rect = chartContainer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                drawChart();
            };
            
            // Initial resize
            setTimeout(resizeCanvas, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeCanvas);
            
            function drawChart() {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Create simple pie chart visualization
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(centerX, centerY) * 0.6;
                
                const colors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#9b59b6'];
                const total = Object.values(counts).reduce((a, b) => a + b, 0);
                
                let currentAngle = 0;
                Object.entries(counts).forEach(([cluster, count], index) => {
                    const sliceAngle = (count / total) * 2 * Math.PI;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                    ctx.closePath();
                    
                    ctx.fillStyle = colors[index % colors.length];
                    ctx.fill();
                    
                    currentAngle += sliceAngle;
                });
                
                // Add title
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.fillText('Clustering Analysis - K-Means', 10, 20);
            }
            
            // Add interpretation below the chart
            const interpretationDiv = document.createElement('div');
            interpretationDiv.style.marginTop = '15px';
            interpretationDiv.style.padding = '15px';
            interpretationDiv.style.backgroundColor = '#f8f9fa';
            interpretationDiv.style.borderRadius = '8px';
            interpretationDiv.style.border = '1px solid #dee2e6';
            
            const total = Object.values(counts).reduce((a, b) => a + b, 0);
            const clusterCount = Object.keys(counts).length;
            const largestCluster = Math.max(...Object.values(counts));
            const smallestCluster = Math.min(...Object.values(counts));
            const clusterSizes = Object.values(counts).sort((a, b) => b - a);
            const balanceRatio = (largestCluster - smallestCluster) / total;
            
            // Determine hydrological clustering quality
            let clusteringQuality = '';
            if (balanceRatio < 0.1) clusteringQuality = '聚类非常均衡';
            else if (balanceRatio < 0.2) clusteringQuality = '聚类相对均衡';
            else if (balanceRatio < 0.3) clusteringQuality = '聚类不够均衡';
            else clusteringQuality = '聚类严重失衡';
            
            // Determine hydrological pattern types
            let hydrologicalPatterns = '';
            if (clusterCount === 2) {
                hydrologicalPatterns = '可能反映积雪期和融雪期两种主要状态';
            } else if (clusterCount === 3) {
                hydrologicalPatterns = '可能反映积雪期、融雪期和过渡期三种状态';
            } else if (clusterCount === 4) {
                hydrologicalPatterns = '可能反映不同季节和天气条件下的雪水当量状态';
            } else {
                hydrologicalPatterns = '反映了复杂的雪水当量变化模式';
            }
            
            // Determine seasonal interpretation
            let seasonalInterpretation = '';
            if (balanceRatio < 0.15) {
                seasonalInterpretation = '各季节雪水当量变化相对均衡，季节性明显';
            } else if (balanceRatio < 0.25) {
                seasonalInterpretation = '存在明显的季节性差异，但变化相对规律';
            } else {
                seasonalInterpretation = '季节性差异显著，可能存在极端天气影响';
            }
            
            // Calculate cluster diversity
            const avgClusterSize = total / clusterCount;
            const diverseClusters = clusterSizes.filter(size => Math.abs(size - avgClusterSize) < avgClusterSize * 0.5).length;
            
            // Determine hydrological applications
            let hydrologicalApplications = '';
            if (balanceRatio < 0.2 && clusterCount <= 4) {
                hydrologicalApplications = '聚类结果可靠，可用于季节性预测和水资源管理';
            } else if (balanceRatio < 0.3) {
                hydrologicalApplications = '聚类结果可用，建议结合其他方法进行验证';
            } else {
                hydrologicalApplications = '聚类结果需要优化，建议调整参数或增加数据';
            }
            
            // Get professional interpretation for clustering analysis
            const clusterData = [avgClusterSize, largestCluster, smallestCluster];
            const interpretation = getProfessionalInterpretation(clusterData, [], balanceRatio, 0, total);
            
            // Display professional interpretation directly in the container
            displayProfessionalInterpretation(container, interpretation);
        }
        
        // Statistical Tests
        async function loadStatisticalTests() {
            try {
                const response = await apiRequest('/api/v1/data-science/statistical-tests?column=snow_water_equivalent_mm');
                if (response.success) {
                    displayStatisticalChart(response.results);
                }
            } catch (error) {
                console.error('Statistical tests failed:', error);
            }
        }

        function displayStatisticalChart(results) {
            const container = document.getElementById('statistical-chart');
            if (!container) {
                console.warn('Statistical chart container not found - Advanced Factors Discovery module may be disabled');
                return;
            }
            if (!results) {
                container.innerHTML = '<div class="text-center text-muted pt-5">No statistical test data</div>';
                return;
            }
            
            container.innerHTML = '';
            
            // Transform API data to expected format
            const tests = [];
            if (results.normality) {
                tests.push({
                    test_name: 'Shapiro-Wilk Normality',
                    p_value: results.normality.shapiro_p_value,
                    statistic: results.normality.shapiro_statistic
                });
            }
            if (results.stationarity) {
                tests.push({
                    test_name: 'ADF Stationarity',
                    p_value: results.stationarity.p_value,
                    statistic: results.stationarity.adf_statistic
                });
            }
            
            if (tests.length === 0) {
                container.innerHTML = '<div class="text-center text-danger pt-5">No valid statistical test data</div>';
                return;
            }
            
            const chartContainer = document.createElement('div');
            chartContainer.style.height = '200px';
            chartContainer.style.width = '100%';
            chartContainer.style.overflow = 'hidden';
            chartContainer.style.position = 'relative';
            container.appendChild(chartContainer);
            
            // Create responsive canvas
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.maxWidth = '100%';
            chartContainer.appendChild(canvas);
            
            // Set canvas size based on container
            const resizeCanvas = () => {
                const rect = chartContainer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                drawChart();
            };
            
            // Initial resize
            setTimeout(resizeCanvas, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeCanvas);
            
            function drawChart() {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                const names = tests.map(t => t.test_name || 'Test');
                const pValues = tests.map(t => t.p_value || 0);
                
                if (pValues.length > 0) {
                    const barWidth = width / pValues.length * 0.8;
                    const barSpacing = width / pValues.length * 0.2;
                    const maxPValue = Math.max(...pValues);
                    
                    pValues.forEach((pValue, index) => {
                        const x = index * (barWidth + barSpacing) + barSpacing / 2;
                        const barHeight = (pValue / maxPValue) * height * 0.8;
                        const y = height - barHeight - 20;
                        
                        ctx.fillStyle = '#3498db';
                        ctx.fillRect(x, y, barWidth, barHeight);
                    });
                    
                    // Add title
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '14px Arial';
                    ctx.fillText('Statistical Tests - P-Values', 10, 20);
                }
            }
            
            // Calculate statistical test metrics
            const significantTests = tests.filter(t => (t.p_value || 1) < 0.05).length;
            const totalTests = tests.length;
            const avgPValue = tests.reduce((sum, t) => sum + (t.p_value || 1), 0) / totalTests;
            const verySignificant = tests.filter(t => (t.p_value || 1) < 0.01).length;
            const significanceRate = (significantTests / totalTests) * 100;
            
            // Get professional interpretation for statistical tests
            const testData = [avgPValue, significanceRate, verySignificant];
            const interpretation = getProfessionalInterpretation(testData, [], significanceRate/100, 0, totalTests);
            
            // Display professional interpretation
            displayProfessionalInterpretation(container, interpretation);
        }
        
        // Factor Discovery
        async function loadFactorDiscovery() {
            try {
                const response = await apiRequest('/api/v1/data-science/factor-discovery');
                if (response.success) {
                    displayFactorsChart(response.results);
                }
            } catch (error) {
                console.error('Factor discovery failed:', error);
            }
        }

        function displayFactorsChart(results) {
            const container = document.getElementById('factors-chart');
            if (!container) {
                console.warn('Factors chart container not found - Advanced Factors Discovery module may be disabled');
                return;
            }
            if (!results || !results.high_predictive) {
                container.innerHTML = '<div class="text-center text-muted pt-5">No factors data</div>';
                return;
            }
            
            container.innerHTML = '';
            
            const chartContainer = document.createElement('div');
            chartContainer.style.height = '200px';
            chartContainer.style.width = '100%';
            chartContainer.style.overflow = 'hidden';
            chartContainer.style.position = 'relative';
            container.appendChild(chartContainer);
            
            const factors = results.high_predictive || [];
            if (factors.length === 0) {
                container.innerHTML = '<div class="text-center text-danger pt-5">No valid factors data</div>';
                return;
            }
            
            // Create responsive canvas
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.maxWidth = '100%';
            chartContainer.appendChild(canvas);
            
            // Set canvas size based on container
            const resizeCanvas = () => {
                const rect = chartContainer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                drawChart();
            };
            
            // Initial resize
            setTimeout(resizeCanvas, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeCanvas);
            
            function drawChart() {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                const names = factors.map(item => item.factor || 'Factor');
                const scores = factors.map(item => item.score || 0);
                
                if (scores.length > 0) {
                    const maxScore = Math.max(...scores);
                    const barHeight = height / scores.length * 0.6;
                    const barSpacing = height / scores.length * 0.4;
                    
                    scores.forEach((score, index) => {
                        const y = index * (barHeight + barSpacing) + barSpacing / 2;
                        const barWidth = (score / maxScore) * width * 0.8;
                        const x = 20;
                        
                        ctx.fillStyle = '#9b59b6';
                        ctx.fillRect(x, y, barWidth, barHeight);
                        
                        // Add text label
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '10px Arial';
                        ctx.fillText(names[index], x + barWidth + 10, y + barHeight / 2 + 4);
                    });
                    
                    // Add title
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '14px Arial';
                    ctx.fillText('Factor Discovery - Predictive Factors', 10, 20);
                }
            }
            
            // Add interpretation below the chart
            const interpretationDiv = document.createElement('div');
            interpretationDiv.style.marginTop = '15px';
            interpretationDiv.style.padding = '15px';
            interpretationDiv.style.backgroundColor = '#f8f9fa';
            interpretationDiv.style.borderRadius = '8px';
            interpretationDiv.style.border = '1px solid #dee2e6';
            
            const topFactor = factors[0];
            const avgScore = factors.reduce((sum, f) => sum + (f.score || 0), 0) / factors.length;
            const highScoreFactors = factors.filter(f => (f.score || 0) > avgScore).length;
            const scoreRange = Math.max(...factors.map(f => f.score || 0)) - Math.min(...factors.map(f => f.score || 0));
            const topFactors = factors.slice(0, 3).map(f => f.factor).join('、');
            
            // Determine hydrological factor quality
            let factorQuality = '';
            if (avgScore > 0.8) factorQuality = '雪水当量预测因子质量极高';
            else if (avgScore > 0.6) factorQuality = '雪水当量预测因子质量较高';
            else if (avgScore > 0.4) factorQuality = '雪水当量预测因子质量中等';
            else factorQuality = '雪水当量预测因子质量较低';
            
            // Determine hydrological predictive power
            let predictivePower = '';
            if (highScoreFactors > factors.length * 0.7) predictivePower = '雪水当量预测能力很强';
            else if (highScoreFactors > factors.length * 0.5) predictivePower = '雪水当量预测能力较强';
            else if (highScoreFactors > factors.length * 0.3) predictivePower = '雪水当量预测能力一般';
            else predictivePower = '雪水当量预测能力有限';
            
            // Determine hydrological factor types
            let factorTypes = '';
            const seasonalFactors = factors.filter(f => f.factor && (f.factor.includes('seasonal') || f.factor.includes('trend') || f.factor.includes('lag')));
            const statisticalFactors = factors.filter(f => f.factor && (f.factor.includes('mean') || f.factor.includes('std') || f.factor.includes('skew')));
            if (seasonalFactors.length > 0 && statisticalFactors.length > 0) {
                factorTypes = '包含季节性和统计特征因子';
            } else if (seasonalFactors.length > 0) {
                factorTypes = '主要包含季节性特征因子';
            } else if (statisticalFactors.length > 0) {
                factorTypes = '主要包含统计特征因子';
            } else {
                factorTypes = '包含多种类型特征因子';
            }
            
            // Determine hydrological applications
            let hydrologicalApplications = '';
            if (avgScore > 0.7 && highScoreFactors > factors.length * 0.5) {
                hydrologicalApplications = '非常适合构建雪水当量预测模型，可用于水资源管理';
            } else if (avgScore > 0.5 && highScoreFactors > factors.length * 0.3) {
                hydrologicalApplications = '可以用于雪水当量季节性预测，辅助水资源规划';
            } else {
                hydrologicalApplications = '需要更多特征工程或数据，当前因子预测能力有限';
            }
            
            // Determine seasonal prediction value
            let seasonalPrediction = '';
            if (topFactors.includes('seasonal') || topFactors.includes('trend')) {
                seasonalPrediction = '顶级因子包含季节性特征，适合融雪期预测';
            } else if (topFactors.includes('lag') || topFactors.includes('mean')) {
                seasonalPrediction = '顶级因子包含时间滞后特征，适合短期预测';
            } else {
                seasonalPrediction = '顶级因子特征多样，预测能力全面';
            }
            
            // Get professional interpretation for factor discovery
            const factorData = [avgScore, highScoreFactors, scoreRange];
            const interpretation = getProfessionalInterpretation(factorData, [], avgScore, 0, factors.length);
            
            // Display professional interpretation
            displayProfessionalInterpretation(container, interpretation);
        }
        
        // ===== END FACTORS DISCOVERY FUNCTIONS =====
        
        // ===== ADVANCED ANALYSIS PORTAL FUNCTIONS =====
        
        // Open advanced analysis portal - redirect to real data analysis page
        function openAdvancedAnalysis() {
            // Option 1: Open in new tab
            window.open('/real_data_analysis_page.html', '_blank');
            
            // Option 2: Open in current tab (uncomment below and comment above if preferred)
            // window.location.href = '/real_data_analysis_page.html';
            
            // Tracking/analytics (if needed)
            try {
                console.log('Advanced Analysis Portal accessed at:', new Date().toISOString());
                
                // Show notification to user
                showNotification('Opening Advanced Hydrology Analysis Suite...', 'info');
                
                // Optional: Track usage statistics
                if (typeof fetch !== 'undefined') {
                    fetch('/api/analytics/portal-access', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            portal: 'advanced_analysis',
                            timestamp: new Date().toISOString(),
                            source_page: 'enhanced_ui'
                        })
                    }).catch(err => console.warn('Analytics tracking failed:', err));
                }
            } catch (error) {
                console.warn('Portal tracking failed:', error);
            }
        }
        
        // Alternative function for inline embedding (if needed in future)
        function embedAdvancedAnalysis() {
            const container = document.getElementById('advanced-analysis-container');
            if (!container) {
                console.error('Advanced analysis container not found');
                return;
            }
            
            // Create iframe for embedding
            const iframe = document.createElement('iframe');
            iframe.src = '/real_data_analysis_page.html';
            iframe.style.width = '100%';
            iframe.style.height = '800px';
            iframe.style.border = 'none';
            iframe.style.borderRadius = '8px';
            
            // Clear container and add iframe
            container.innerHTML = '';
            container.appendChild(iframe);
            
            showNotification('Advanced analysis tools embedded successfully', 'success');
        }
        
        // Initialize advanced analysis features
        function initializeAdvancedAnalysisFeatures() {
            // Add feature list styling
            const addFeatureListStyles = () => {
                const style = document.createElement('style');
                style.textContent = `
                    .feature-list {
                        list-style: none;
                        padding: 0;
                        margin: 0;
                    }
                    
                    .feature-list li {
                        padding: 0.5rem 0;
                        border-bottom: 1px solid #f1f3f4;
                        display: flex;
                        align-items: center;
                        gap: 0.5rem;
                    }
                    
                    .feature-list li:last-child {
                        border-bottom: none;
                    }
                    
                    .feature-list i {
                        width: 16px;
                        text-align: center;
                    }
                    
                    .text-purple {
                        color: #9b59b6;
                    }
                    
                    .analysis-portal {
                        text-align: center;
                        padding: 1.5rem;
                        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                        border-radius: 12px;
                        border: 2px dashed #4A90E2;
                        transition: all 0.3s ease;
                    }
                    
                    .analysis-portal:hover {
                        border-color: #357abd;
                        background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
                        transform: translateY(-2px);
                    }
                    
                    .portal-features .text-small {
                        font-size: 0.85rem;
                        color: #666;
                        margin: 0;
                    }
                    
                    .btn-lg {
                        padding: 1rem 2rem;
                        font-size: 1.1rem;
                        font-weight: 600;
                    }
                    
                    .analysis-features {
                        margin-top: 1.5rem;
                    }
                    
                    .text-muted {
                        color: #6c757d;
                    }
                    
                    .row {
                        display: flex;
                        flex-wrap: wrap;
                        margin: 0 -15px;
                    }
                    
                    .col-md-6, .col-md-4, .col-md-8 {
                        padding: 0 15px;
                        flex: 0 0 50%;
                        max-width: 50%;
                    }
                    
                    .col-md-4 {
                        flex: 0 0 33.33333%;
                        max-width: 33.33333%;
                    }
                    
                    .col-md-8 {
                        flex: 0 0 66.66667%;
                        max-width: 66.66667%;
                    }
                    
                    @media (max-width: 768px) {
                        .col-md-6, .col-md-4, .col-md-8 {
                            flex: 0 0 100%;
                            max-width: 100%;
                        }
                    }
                `;
                document.head.appendChild(style);
            };
            
            // Add styles if not already present
            if (!document.querySelector('style[data-advanced-analysis]')) {
                addFeatureListStyles();
                document.querySelector('style:last-of-type').setAttribute('data-advanced-analysis', 'true');
            }
            
            console.log('Advanced analysis features initialized');
        }
        
        // Call initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeAdvancedAnalysisFeatures();
        });
        
        // ===== END ADVANCED ANALYSIS PORTAL FUNCTIONS =====

        // Enhanced Interpretation System - English Only
        // Integrates with Hydrology Knowledge Base for professional analysis
        
        // Professional interpretation templates
        const interpretationTemplates = {
            trend_analysis: {
                strong_increasing: {
                    title: "Strong Increasing Trend in SWE",
                    description: "Strong increasing trend in SWE indicates significant accumulation patterns that may reflect climate change impacts or natural variability cycles.",
                    implications: [
                        "Potential for increased spring flood risk",
                        "Enhanced water storage for summer months",
                        "Possible climate change signal",
                        "Need for updated flood protection standards"
                    ]
                },
                moderate_increasing: {
                    title: "Moderate Increasing Trend in SWE",
                    description: "Moderate increasing trend suggests gradual changes in winter precipitation patterns or snow retention.",
                    implications: [
                        "Slight increase in flood risk",
                        "Improved water resource availability",
                        "Monitoring recommended for trend continuation"
                    ]
                },
                stable: {
                    title: "Stable SWE Patterns",
                    description: "Stable SWE patterns indicate consistent winter climate conditions and predictable hydrological behavior.",
                    implications: [
                        "Reliable flood forecasting possible",
                        "Consistent water resource planning",
                        "Existing infrastructure adequate"
                    ]
                },
                decreasing: {
                    title: "Decreasing SWE Trend",
                    description: "Decreasing SWE trend may indicate climate change impacts, reduced winter precipitation, or earlier melt onset.",
                    implications: [
                        "Reduced flood risk but potential drought concerns",
                        "Earlier spring runoff timing",
                        "Possible water resource challenges",
                        "Need for adaptation strategies"
                    ]
                }
            },
            
            seasonal_patterns: {
                early_peak: {
                    title: "Early Peak SWE Pattern",
                    description: "Early peak SWE suggests rapid winter accumulation followed by early melt onset.",
                    implications: [
                        "Earlier spring flood risk",
                        "Extended growing season potential",
                        "Reduced summer water availability",
                        "Altered ecosystem timing"
                    ]
                },
                late_peak: {
                    title: "Late Peak SWE Pattern",
                    description: "Late peak SWE indicates prolonged winter conditions with delayed melt onset.",
                    implications: [
                        "Delayed spring flood risk",
                        "Compressed growing season",
                        "Extended winter recreation opportunities",
                        "Potential for rapid melt events"
                    ]
                },
                double_peak: {
                    title: "Double Peak SWE Pattern",
                    description: "Double peak pattern suggests complex winter weather with multiple accumulation and melt cycles.",
                    implications: [
                        "Multiple flood risk periods",
                        "Complex forecasting requirements",
                        "Variable water availability",
                        "Need for adaptive management"
                    ]
                }
            },
            
            anomaly_assessment: {
                extreme_high: {
                    title: "Extremely High SWE Values",
                    description: "Extremely high SWE values represent significant departure from normal conditions.",
                    causes: [
                        "Exceptional winter precipitation",
                        "Cold temperatures limiting melt",
                        "Atmospheric river events",
                        "Climate change impacts"
                    ],
                    risks: [
                        "High flood potential",
                        "Infrastructure stress",
                        "Emergency response needs",
                        "Economic impacts"
                    ]
                },
                extreme_low: {
                    title: "Extremely Low SWE Values",
                    description: "Extremely low SWE values indicate drought conditions or unusual winter weather.",
                    causes: [
                        "Below-normal precipitation",
                        "Early melt onset",
                        "Warm winter temperatures",
                        "Climate change trends"
                    ],
                    risks: [
                        "Reduced water availability",
                        "Agricultural impacts",
                        "Ecosystem stress",
                        "Economic consequences"
                    ]
                }
            }
        };
        
        // Get professional interpretation based on data
        function getProfessionalInterpretation(trendData, seasonalData, anomalyScore, volatility, trendStrength) {
            // Determine trend characteristics
            const trendChange = trendData.length > 1 ? 
                ((trendData[trendData.length - 1] - trendData[0]) / Math.abs(trendData[0])) * 100 : 0;
            
            let trendDirection = "stable";
            let trendSignificance = "Stable";
            let trendTemplate = interpretationTemplates.trend_analysis.stable;
            
            if (Math.abs(trendChange) > 20) {
                trendDirection = trendChange > 0 ? "strong_increasing" : "decreasing";
                trendSignificance = trendChange > 0 ? "Strong Increasing" : "Strong Decreasing";
                trendTemplate = interpretationTemplates.trend_analysis[trendDirection] || interpretationTemplates.trend_analysis.stable;
            } else if (Math.abs(trendChange) > 10) {
                trendDirection = trendChange > 0 ? "moderate_increasing" : "decreasing";
                trendSignificance = trendChange > 0 ? "Moderate Increasing" : "Moderate Decreasing";
                trendTemplate = interpretationTemplates.trend_analysis[trendDirection] || interpretationTemplates.trend_analysis.stable;
            }
            
            // Determine seasonal pattern
            let seasonalPattern = "normal";
            let seasonalTemplate = interpretationTemplates.seasonal_patterns.early_peak;
            
            if (seasonalData.length > 0) {
                const seasonalStrength = Math.max(...seasonalData) - Math.min(...seasonalData);
                if (seasonalStrength > trendStrength * 0.5) {
                    seasonalPattern = "early_peak";
                    seasonalTemplate = interpretationTemplates.seasonal_patterns.early_peak;
                } else if (seasonalStrength > trendStrength * 0.2) {
                    seasonalPattern = "late_peak";
                    seasonalTemplate = interpretationTemplates.seasonal_patterns.late_peak;
                }
            }
            
            // Determine anomaly assessment
            let anomalyTemplate = interpretationTemplates.anomaly_assessment.extreme_high;
            if (Math.abs(anomalyScore) > 2.0) {
                anomalyTemplate = anomalyScore > 0 ? 
                    interpretationTemplates.anomaly_assessment.extreme_high :
                    interpretationTemplates.anomaly_assessment.extreme_low;
            }
            
            return {
                trend: {
                    title: trendTemplate.title,
                    description: trendTemplate.description,
                    magnitude: `${Math.abs(trendChange).toFixed(1)}%`,
                    direction: trendSignificance,
                    implications: trendTemplate.implications
                },
                seasonal: {
                    title: seasonalTemplate.title,
                    description: seasonalTemplate.description,
                    pattern: seasonalPattern,
                    implications: seasonalTemplate.implications
                },
                anomaly: {
                    title: anomalyTemplate.title,
                    description: anomalyTemplate.description,
                    score: anomalyScore,
                    severity: Math.abs(anomalyScore) > 2.0 ? "extreme" : Math.abs(anomalyScore) > 1.0 ? "moderate" : "normal",
                    causes: anomalyTemplate.causes,
                    risks: anomalyTemplate.risks
                },
                data_quality: {
                    volatility: volatility.toFixed(2),
                    stability: volatility > trendStrength * 0.3 ? "High variability, monitor for anomalies" : "Relatively stable, data reliable"
                }
            };
        }
        
        // Generate monitoring recommendations
        function generateMonitoringRecommendations(interpretation) {
            const recommendations = [];
            
            // Based on trend
            if (interpretation.trend.direction.includes("Increasing")) {
                recommendations.push("Monitor flood protection infrastructure capacity");
                recommendations.push("Update flood risk assessments and emergency plans");
                recommendations.push("Consider adaptive management strategies for changing conditions");
            } else if (interpretation.trend.direction.includes("Decreasing")) {
                recommendations.push("Assess water resource availability for summer months");
                recommendations.push("Monitor drought indicators and agricultural impacts");
                recommendations.push("Consider water conservation and efficiency measures");
            }
            
            // Based on anomaly
            if (interpretation.anomaly.severity === "extreme") {
                recommendations.push("Implement enhanced monitoring and early warning systems");
                recommendations.push("Prepare emergency response protocols");
                recommendations.push("Communicate risks to stakeholders and public");
            } else if (interpretation.anomaly.severity === "moderate") {
                recommendations.push("Increase monitoring frequency");
                recommendations.push("Review and update response plans");
                recommendations.push("Prepare for potential extreme events");
            }
            
            // General recommendations
            recommendations.push("Maintain regular data quality assessments");
            recommendations.push("Update models with new observations");
            recommendations.push("Coordinate with regional water management agencies");
            
            return recommendations;
        }
        
        // Display professional interpretation
        function displayProfessionalInterpretation(container, interpretation) {
            const recommendations = generateMonitoringRecommendations(interpretation);
            
            container.innerHTML = `
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h6 class="mb-0"><i class="fas fa-chart-line"></i> Professional SWE Analysis - Hydrological Interpretation</h6>
                    </div>
                    <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                                <h6 class="text-primary">${interpretation.trend.title}</h6>
                                <p class="small text-muted">${interpretation.trend.description}</p>
                                <p><strong>Trend Magnitude:</strong> ${interpretation.trend.magnitude} change</p>
                                <p><strong>Direction:</strong> ${interpretation.trend.direction}</p>
                                <ul class="small">
                                    ${interpretation.trend.implications.map(imp => `<li>${imp}</li>`).join('')}
                                </ul>
                    </div>
                    <div class="col-md-6">
                                <h6 class="text-info">${interpretation.seasonal.title}</h6>
                                <p class="small text-muted">${interpretation.seasonal.description}</p>
                                <p><strong>Pattern:</strong> ${interpretation.seasonal.pattern}</p>
                                <ul class="small">
                                    ${interpretation.seasonal.implications.map(imp => `<li>${imp}</li>`).join('')}
                                </ul>
                    </div>
                </div>
                        
                        <hr>
                        
                        <div class="row">
                            <div class="col-md-6">
                                <h6 class="text-warning">${interpretation.anomaly.title}</h6>
                                <p class="small text-muted">${interpretation.anomaly.description}</p>
                                <p><strong>Anomaly Score:</strong> ${interpretation.anomaly.score.toFixed(2)} (${interpretation.anomaly.severity})</p>
                                <p><strong>Data Quality:</strong> ${interpretation.data_quality.stability}</p>
                            </div>
                            <div class="col-md-6">
                                <h6 class="text-success">Management Recommendations</h6>
                                <ul class="small">
                                    ${recommendations.map(rec => `<li>${rec}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Auto-load statistical tests when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Page loaded, auto-loading statistical tests...');
            setTimeout(() => {
                loadStatisticalTests();
            }, 1000);
        });
        
        // Also load when the tab becomes visible
        function showMainTab(tabName) {
            // Hide all main content sections
            document.querySelectorAll('.main-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all main tabs
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected content
            document.getElementById(tabName + '-content').classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Auto-load data when switching to data science tab
            if (tabName === 'data-science') {
                console.log('Switching to data science tab, loading all analyses...');
                setTimeout(() => {
                    loadStatisticalTests();
                }, 500);
            }
        }
    </script>
</body>
</html>
