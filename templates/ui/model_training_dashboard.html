<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HydrAI-SWE Model Training Monitor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script>
        // Fix for 'exports is not defined' error in browser environment
        window.exports = {};
        window.module = { exports: window.exports };

        // Ensure Chart.js is available globally
        if (typeof Chart === 'undefined') {
            console.warn('Chart.js not loaded, charts may not work properly');
        }

        // Global error handler to catch any remaining issues
        window.addEventListener('error', function (e) {
            if (e.error && e.error.message && e.error.message.includes('exports is not defined')) {
                console.warn('Exports error detected, attempting recovery...');
                // Try to fix it
                if (typeof window.exports === 'undefined') {
                    window.exports = {};
                }
                if (typeof window.module === 'undefined') {
                    window.module = { exports: window.exports };
                }
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .card h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .model-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .model-item {
            background: #f7fafc;
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }

        .model-item:hover {
            background: #edf2f7;
            transform: translateX(5px);
        }

        .model-name {
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .model-status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-trained {
            background: #48bb78;
        }

        .status-not-trained {
            background: #ed8936;
        }

        .status-error {
            background: #f56565;
        }

        .status-training {
            background: #4299e1;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .training-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .performance-chart {
            height: 300px;
            margin-top: 20px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .drift-detection {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .drift-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #fed7d7;
        }

        .drift-item:last-child {
            border-bottom: none;
        }

        .drift-score {
            font-weight: bold;
        }

        .drift-high {
            color: #e53e3e;
        }

        .drift-medium {
            color: #ed8936;
        }

        .drift-low {
            color: #48bb78;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #4a5568;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-success {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            color: #22543d;
        }

        .alert-error {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            color: #742a2a;
        }

        .alert-warning {
            background: #fffaf0;
            border: 1px solid #fbd38d;
            color: #744210;
        }

        .feature-importance {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .feature-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .feature-bar {
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 0 10px;
            overflow: hidden;
        }

        .feature-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .nav-links {
            text-align: center;
            margin-bottom: 30px;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            margin: 0 15px;
            padding: 10px 20px;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .nav-links a:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .nav-links a.active {
            background: rgba(255, 255, 255, 0.3);
            font-weight: bold;
        }

        .system-health {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .health-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        .health-unhealthy {
            background: #f56565;
        }

        .timestamp {
            color: #718096;
            font-size: 0.9em;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-water"></i> HydrAI-SWE</h1>
            <p>Intelligent Snow Water Equivalent Prediction System</p>
        </div>

        <div class="nav-links">
            <a href="/home"><i class="fas fa-home"></i> Home</a>
            <a href="/dashboard"><i class="fas fa-tachometer-alt"></i> Dashboard</a>
            <a href="/analysis"><i class="fas fa-chart-line"></i> Analysis</a>
            <a href="/model" class="active"><i class="fas fa-robot"></i> Training</a>
            <a href="/knowledge"><i class="fas fa-book"></i> Knowledge Base</a>
            <a href="/about"><i class="fas fa-info-circle"></i> About</a>
        </div>

        <div id="system-health" class="system-health">
            <div class="health-indicator" id="health-indicator"></div>
            <span id="health-text">Checking system status...</span>
        </div>

        <!-- System Status Card -->
        <div class="card">
            <h2>üìä Model Training Status</h2>
            <div class="training-controls">
                <button class="btn" onclick="refreshAllModels()">üîÑ Refresh Status</button>
                <button class="btn btn-success" onclick="syncAndTrainAll()" id="sync-and-train-btn">üöÄ Sync Data & Train
                    Models</button>
                <button class="btn btn-success" onclick="trainAllModels()">üöÄ Start Training</button>
                <button class="btn btn-danger" onclick="detectAllDrift()">üîç Detect Drift</button>
                <button class="btn" onclick="exportPerformanceReport()">üìà Export Report</button>
            </div>
            <div id="models-status" class="model-status">
                <!-- Model status will be loaded here dynamically -->
            </div>
            <div class="timestamp" id="status-timestamp"></div>
        </div>

        <!-- Data Source Configuration Card -->
        <div class="card">
            <h2>‚öôÔ∏è Data Source Configuration</h2>
            <div class="training-controls">
                <button class="btn" onclick="refreshDataSourceStatus()">üîÑ Refresh Status</button>
                <button class="btn btn-success" onclick="syncAllDataSources(event)">üì• Sync All Sources</button>
                <button class="btn" onclick="openDataSourceSettings()">‚öôÔ∏è Configure Sources</button>
            </div>
            <div id="data-source-status">
                <!-- Data source status will be loaded here -->
            </div>
        </div>

        <div class="dashboard-grid">
            <!-- Training Performance Chart -->
            <div class="card">
                <h2>üìà Training Performance Trends</h2>
                <div class="performance-chart">
                    <canvas id="performanceChart"></canvas>
                </div>
                <div id="performance-chart-message" style="text-align: center; padding: 20px; color: #718096;">
                    <p>No training data available. Please start model training to view performance trends.</p>
                    <button class="btn btn-success" onclick="trainAllModels()" style="margin-top: 10px;">üöÄ Start
                        Initial Training</button>
                </div>
            </div>

            <!-- System Metrics -->
            <div class="card">
                <h2>üéØ System Metrics</h2>
                <div class="metrics-grid" id="system-metrics">
                    <!-- Metrics will be loaded here dynamically -->
                </div>
            </div>

            <!-- Data Drift Monitoring -->
            <div class="card">
                <h2>‚ö†Ô∏è Data Drift Detection</h2>
                <div id="drift-detection">
                    <!-- Drift detection results will be displayed here -->
                </div>
            </div>

            <!-- Feature Importance -->
            <div class="card">
                <h2>üîç Feature Importance</h2>
                <div id="feature-importance">
                    <!-- Feature importance will be displayed here -->
                </div>
            </div>

            <!-- Bayesian Correlation Analysis (Èò∂ÊÆµ1Êñ∞ÂäüËÉΩ) -->
            <div class="card">
                <h2>üß† Bayesian Network Correlation Analysis</h2>
                <div id="correlation-analysis">
                    <!-- Correlation analysis will be displayed here -->
                </div>
            </div>
        </div>

        <!-- Training History -->
        <div class="card">
            <h2>üìö Training History</h2>
            <div id="training-history">
                <!-- Training history will be displayed here -->
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let performanceChart = null;
        let modelStatusData = {};
        let systemHealth = 'unknown';

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            initializeDashboard();
            loadModelsStatus();
            loadSystemMetrics();
            loadPerformanceChart();
            loadTrainingHistory(); // Âä†ËΩΩËÆ≠ÁªÉÂéÜÂè≤
            refreshDataSourceStatus();
            loadDriftDetection();
            loadFeatureImportance();
            loadCorrelationAnalysis(); // Âä†ËΩΩÁõ∏ÂÖ≥ÊÄßÂàÜÊûêÔºàÈò∂ÊÆµ1Êñ∞ÂäüËÉΩÔºâ
            setInterval(refreshDashboard, 30000); // Refresh every 30 seconds
        });

        // Initialize dashboard
        function initializeDashboard() {
            console.log('Initializing model training monitoring dashboard...');

            // Á°Æ‰øùÂÖ≥ÈîÆÂáΩÊï∞Â∑≤ÂÆö‰πâ
            if (typeof refreshDataSourceStatus === 'function') {
                console.log('‚úÖ refreshDataSourceStatus function is available');
            } else {
                console.error('‚ùå refreshDataSourceStatus function is NOT available');
            }

            if (typeof syncAllDataSources === 'function') {
                console.log('‚úÖ syncAllDataSources function is available');
            } else {
                console.error('‚ùå syncAllDataSources function is NOT available');
            }

            // È¶ñÂÖàÊ£ÄÊü•Ê®°ÂûãËÆ≠ÁªÉÊ®°ÂùóÊòØÂê¶ÂèØÁî®
            checkModuleAvailability().then(() => {
                checkSystemHealth();
            }).catch(error => {
                console.error('Failed to check module availability:', error);
            });
        }

        // Ê£ÄÊü•Ê®°ÂûãËÆ≠ÁªÉÊ®°ÂùóÊòØÂê¶ÂèØÁî®
        async function checkModuleAvailability() {
            try {
                const response = await fetch('/health', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });
                if (response.ok) {
                    const health = await response.json();
                    if (health.modules && health.modules.model_training === false) {
                        // Ê®°ÂûãËÆ≠ÁªÉÊ®°Âùó‰∏çÂèØÁî®ÔºåÊòæÁ§∫Ë≠¶Âëä
                        const container = document.getElementById('models-status');
                        container.innerHTML = `
                            <div style="padding: 20px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; margin: 20px 0;">
                                <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Model Training Module Unavailable</h3>
                                <p style="color: #856404;">The Model Training API module is not enabled in the production environment. Please contact the system administrator to enable this feature.</p>
                                <p style="color: #856404; margin-bottom: 0;">Feature Status: Model Training API Disabled</p>
                            </div>
                        `;
                        // Á¶ÅÁî®ÊâÄÊúâÁõ∏ÂÖ≥ÊåâÈíÆ
                        const buttons = document.querySelectorAll('button.btn');
                        buttons.forEach(btn => {
                            if (btn.textContent.includes('ËÆ≠ÁªÉ') || btn.textContent.includes('Training') ||
                                btn.textContent.includes('TRAINING') || btn.textContent.includes('DRIFT')) {
                                btn.disabled = true;
                                btn.style.opacity = '0.5';
                                btn.style.cursor = 'not-allowed';
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Failed to check module availability:', error);
            }
        }

        // Check system health status
        async function checkSystemHealth() {
            try {
                const response = await fetch('/api/training/health', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });

                if (!response.ok) {
                    if (response.status === 404) {
                        // APIÁ´ØÁÇπ‰∏çÂ≠òÂú®Êó∂ÊòæÁ§∫Ë≠¶Âëä
                        document.getElementById('health-indicator').className = 'health-indicator health-unhealthy';
                        document.getElementById('health-text').textContent = 'Training API not available';
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const health = await response.json();

                systemHealth = health.status || 'unknown';
                const indicator = document.getElementById('health-indicator');
                const text = document.getElementById('health-text');

                if (health.status === 'healthy') {
                    indicator.className = 'health-indicator';
                    text.textContent = `System healthy - ${health.timestamp || new Date().toLocaleString()}`;
                } else {
                    indicator.className = 'health-indicator health-unhealthy';
                    text.textContent = `System ${health.status || 'unknown'} - ${health.message || health.timestamp || ''}`;
                }
            } catch (error) {
                console.error('Failed to check system health status:', error);
                document.getElementById('health-indicator').className = 'health-indicator health-unhealthy';
                document.getElementById('health-text').textContent = 'System connection failed';
            }
        }

        // Âä†ËΩΩÊ®°ÂûãÁä∂ÊÄÅ
        async function loadModelsStatus() {
            try {
                const response = await fetch('/api/training/models/status', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });

                if (!response.ok) {
                    if (response.status === 404) {
                        // API‰∏çÂ≠òÂú®Êó∂ÊòæÁ§∫Á©∫Áä∂ÊÄÅ
                        modelStatusData = { models: {} };
                        renderModelsStatus(modelStatusData);
                        updateStatusTimestamp();
                        showAlert('Model training API unavailable', 'warning');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                modelStatusData = data;
                renderModelsStatus(data);
                updateStatusTimestamp();

                // Â¶ÇÊûúÊ≤°ÊúâÊ®°ÂûãÊï∞ÊçÆÔºåÊòæÁ§∫ÊèêÁ§∫
                if (!data.models || Object.keys(data.models).length === 0) {
                    const container = document.getElementById('models-status');
                    if (container.innerHTML.trim() === '') {
                        if (data.overall_status === 'module_unavailable' || data.message) {
                            container.innerHTML = `
                                <div style="padding: 20px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; margin: 20px 0;">
                                    <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Model Training Module Unavailable</h3>
                                    <p style="color: #856404;">${data.message || 'The Model Training API module is not enabled in the production environment. Please contact the system administrator to enable this feature.'}</p>
                                </div>
                            `;
                        } else {
                            container.innerHTML = '<p style="padding: 15px; color: #718096;">No model data available. Please start model training.</p>';
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to load model status:', error);
                console.error('ÈîôËØØËØ¶ÊÉÖ:', error.message, error.stack);
                // ÊòæÁ§∫ÂèãÂ•ΩÁöÑÈîôËØØ‰ø°ÊÅØ
                const container = document.getElementById('model-status');
                if (container) {
                    container.innerHTML = `
                        <div class="alert alert-warning">
                            <p>‚ö†Ô∏è Unable to load model status</p>
                            <p style="font-size: 0.9em; margin-top: 5px;">Error: ${error.message || 'Network Error'}</p>
                            <p style="font-size: 0.85em; margin-top: 5px; color: #666;">
                                Please check:<br>
                                1. Server is running<br>
                                2. API endpoint /api/training/models/status is available<br>
                                3. Network connection is normal
                            </p>
                        </div>
                    `;
                }
                // ÊòæÁ§∫Á©∫Áä∂ÊÄÅ‰Ωú‰∏∫ÂêéÂ§á
                modelStatusData = { models: {} };
                renderModelsStatus(modelStatusData);
            }
        }

        // Render model status
        function renderModelsStatus(data) {
            const container = document.getElementById('models-status');
            container.innerHTML = '';

            if (data.models) {
                Object.entries(data.models).forEach(([modelName, modelInfo]) => {
                    const modelItem = document.createElement('div');
                    modelItem.className = 'model-item';

                    const statusClass = modelInfo.status === 'trained' ? 'status-trained' :
                        modelInfo.status === 'training' ? 'status-training' : 'status-not-trained';

                    modelItem.innerHTML = `
                        <div class="model-name">
                            <span class="model-status-indicator ${statusClass}"></span>
                            ${modelName.replace('_', ' ').toUpperCase()}
                        </div>
                        <div>Status: ${modelInfo.status}</div>
                        <div>Training Count: ${modelInfo.training_count || 0}</div>
                        ${modelInfo.performance ? `
                            <div>Accuracy: ${(modelInfo.performance.accuracy * 100).toFixed(1)}%</div>
                        ` : ''}
                    `;

                    container.appendChild(modelItem);
                });
            }
        }

        // Âä†ËΩΩÁ≥ªÁªüÊåáÊ†á
        async function loadSystemMetrics() {
            try {
                const response = await fetch('/api/training/models/status', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                const metricsContainer = document.getElementById('system-metrics');
                metricsContainer.innerHTML = '';

                const metrics = [
                    {
                        label: 'Total Models',
                        value: Object.keys(data.models || {}).length,
                        color: '#667eea'
                    },
                    {
                        label: 'Trained Models',
                        value: Object.values(data.models || {}).filter(m => m.status === 'trained').length,
                        color: '#48bb78'
                    },
                    {
                        label: 'Models in Training',
                        value: Object.values(data.models || {}).filter(m => m.status === 'training').length,
                        color: '#4299e1'
                    }
                ];

                metrics.forEach(metric => {
                    const metricCard = document.createElement('div');
                    metricCard.className = 'metric-card';
                    metricCard.innerHTML = `
                        <div class="metric-value">${metric.value}</div>
                        <div class="metric-label">${metric.label}</div>
                    `;
                    metricsContainer.appendChild(metricCard);
                });
            } catch (error) {
                console.error('Failed to load system metrics:', error);
                const metricsContainer = document.getElementById('system-metrics');
                if (metricsContainer) {
                    metricsContainer.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #f56565;">
                            <p>‚ö†Ô∏è Unable to load system metrics</p>
                            <p style="font-size: 0.9em; margin-top: 5px;">Error: ${error.message || 'Network Error'}</p>
                            <p style="font-size: 0.85em; margin-top: 5px; color: #666;">
                                Please check:<br>
                                1. Server is running<br>
                                2. API endpoints are available<br>
                                3. Network connection is normal
                            </p>
                        </div>
                    `;
                }
            }
        }

        // Âä†ËΩΩÊÄßËÉΩÂõæË°®
        async function loadPerformanceChart() {
            try {
                console.log('üìä Starting to load performance chart...');

                // Ëé∑ÂèñÊ¥™Ê∞¥È¢ÑÊµãÊ®°ÂûãÁöÑÊÄßËÉΩÂéÜÂè≤
                const response = await fetch('/api/training/models/flood_prediction/performance', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('üìä API returned data:', data);

                const chartCanvas = document.getElementById('performanceChart');
                if (!chartCanvas) {
                    console.error('‚ùå Cannot find chart canvas element');
                    return;
                }

                const ctx = chartCanvas.getContext('2d');
                const messageDiv = document.getElementById('performance-chart-message');

                if (performanceChart) {
                    performanceChart.destroy();
                    performanceChart = null;
                }

                const performanceHistory = data.performance_history || [];
                console.log('üìä Performance history records:', performanceHistory.length);

                if (performanceHistory.length === 0) {
                    // Ê≤°ÊúâËÆ≠ÁªÉÊï∞ÊçÆÔºåÊòæÁ§∫ÊèêÁ§∫‰ø°ÊÅØ
                    console.log('‚ö†Ô∏è No training history data');
                    if (messageDiv) {
                        messageDiv.style.display = 'block';
                    }
                    performanceChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: []
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Model Performance Trends'
                                }
                            }
                        }
                    });
                    return;
                }

                // ÊúâÊï∞ÊçÆÔºåÈöêËóèÊèêÁ§∫‰ø°ÊÅØÂπ∂ÊòæÁ§∫ÂõæË°®
                if (messageDiv) {
                    messageDiv.style.display = 'none';
                }

                // ÂáÜÂ§áÊï∞ÊçÆÔºàÂÖàÂáÜÂ§áÔºåÁî®‰∫éËÆ°ÁÆóYËΩ¥ËåÉÂõ¥Ôºâ
                const accuracyData = performanceHistory.map(p => {
                    // ÊîØÊåÅ‰∏§ÁßçÊï∞ÊçÆÁªìÊûÑÔºöp.accuracy Êàñ p.performance.accuracy
                    const acc = (p.accuracy !== undefined ? p.accuracy : (p.performance && p.performance.accuracy !== undefined ? p.performance.accuracy : 0));
                    return acc * 100;
                });

                const f1Data = performanceHistory.map(p => {
                    // ÊîØÊåÅ‰∏§ÁßçÊï∞ÊçÆÁªìÊûÑÔºöp.f1_score Êàñ p.performance.f1_score
                    const f1 = (p.f1_score !== undefined ? p.f1_score : (p.performance && p.performance.f1_score !== undefined ? p.performance.f1_score : 0));
                    return f1 * 100;
                });

                // ËÆ°ÁÆóÊï∞ÊçÆËåÉÂõ¥ÔºåÁî®‰∫éÂä®ÊÄÅË∞ÉÊï¥YËΩ¥
                const allValues = [...accuracyData, ...f1Data].filter(v => v != null && !isNaN(v) && v > 0);

                const minValue = allValues.length > 0 ? Math.min(...allValues) : 0;
                const maxValue = allValues.length > 0 ? Math.max(...allValues) : 100;

                // Â¶ÇÊûúÊï∞ÊçÆÈÉΩÂú®90%‰ª•‰∏äÔºå‰ªé85%ÂºÄÂßãÔºõÂê¶Âàô‰ªéÊúÄÂ∞èÂÄº-5%ÂºÄÂßãÔºå‰ΩÜ‰∏ç‰Ωé‰∫é0
                const yAxisMin = Math.max(0, Math.min(85, minValue - 5));

                // Â§ÑÁêÜÊó•ÊúüÊ†áÁ≠æÔºåÁ°Æ‰øùÊ≠£Á°ÆËß£Êûê
                const labels = performanceHistory.map((p, index) => {
                    try {
                        const date = new Date(p.timestamp);
                        if (isNaN(date.getTime())) {
                            // Â¶ÇÊûúÊó•ÊúüËß£ÊûêÂ§±Ë¥•ÔºåÂ∞ùËØïÂÖ∂‰ªñÊ†ºÂºè
                            const dateStr = p.timestamp.split('T')[0];
                            console.warn(`Êó•ÊúüËß£ÊûêÂ§±Ë¥• (Á¥¢Âºï ${index}):`, p.timestamp, '‰ΩøÁî®:', dateStr);
                            return dateStr;
                        }
                        const dateStr = date.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
                        return dateStr;
                    } catch (e) {
                        console.warn('Êó•ÊúüËß£ÊûêÂºÇÂ∏∏ (Á¥¢Âºï ' + index + '):', p.timestamp, e);
                        return p.timestamp.split('T')[0] || 'Êú™Áü•Êó•Êúü';
                    }
                });

                console.log('üìä ÊÄßËÉΩÂéÜÂè≤Êï∞ÊçÆ:', performanceHistory);
                console.log('üìÖ Date Labels:', labels);
                console.log('üìä Accuracy Data:', accuracyData);
                console.log('üìä F1 Score Data:', f1Data);
                console.log('üìä Y-Axis Range:', yAxisMin, 'to 100');

                // ÂàõÂª∫ÂõæË°®
                performanceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Accuracy (%)',
                            data: accuracyData,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            fill: true,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }, {
                            label: 'F1 Score (%)',
                            data: f1Data,
                            borderColor: '#48bb78',
                            backgroundColor: 'rgba(72, 187, 120, 0.1)',
                            tension: 0.4,
                            fill: true,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                min: yAxisMin,  // Use dynamically calculated minimum value
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Performance Metric (%)'
                                },
                                ticks: {
                                    stepSize: 2,  // Reduce step size for finer display of changes above 90%
                                    callback: function (value) {
                                        return value.toFixed(1) + '%';
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Training Time'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false
                            },
                            title: {
                                display: true,
                                text: 'Model Performance Trends',
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                });

                console.log('‚úÖ Performance chart created successfully');

            } catch (error) {
                console.error('‚ùå Failed to load performance chart:', error);
                const chartCanvas = document.getElementById('performanceChart');
                const messageDiv = document.getElementById('performance-chart-message');

                if (messageDiv) {
                    messageDiv.style.display = 'block';
                    messageDiv.innerHTML = `
                        <p>‚ùå Failed to load performance chart</p>
                        <p style="font-size: 0.9em; margin-top: 10px;">${error.message || 'Unknown Error'}</p>
                        <button class="btn btn-success" onclick="loadPerformanceChart()" style="margin-top: 10px;">üîÑ Retry</button>
                    `;
                }

                // Create empty chart to avoid errors
                if (chartCanvas) {
                    try {
                        const ctx = chartCanvas.getContext('2d');
                        if (performanceChart) {
                            performanceChart.destroy();
                        }
                        performanceChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: [],
                                datasets: []
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: 'top'
                                    },
                                    title: {
                                        display: true,
                                        text: 'Model Performance Trends'
                                    }
                                }
                            }
                        });
                    } catch (innerError) {
                        console.error('Failed to create empty chart:', innerError);
                    }
                }
            }
        }

        // Refresh data source status
        async function refreshDataSourceStatus() {
            console.log('üîÑ Refreshing data source status...');
            try {
                const response = await fetch('/api/sync/status', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });
                console.log('üì° Data source status response:', response.status, response.statusText);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: `HTTP ${response.status}` }));
                    throw new Error(errorData.detail || errorData.message || `HTTP ${response.status}`);
                }

                const data = await response.json();

                const container = document.getElementById('data-source-status');
                container.innerHTML = '';

                if (data.status === 'success') {
                    const statusCard = document.createElement('div');
                    statusCard.className = 'model-item';
                    const hasData = data.latest_date !== null && data.latest_date !== undefined && data.latest_date !== '';
                    const daysBehind = data.days_behind !== null && data.days_behind !== undefined ? data.days_behind : null;

                    // Determine if sync is needed
                    const needsSync = !hasData || (daysBehind !== null && daysBehind > 0);

                    statusCard.innerHTML = `
                        <div class="model-name">
                            <span class="model-status-indicator ${needsSync ? 'status-not-trained' : 'status-trained'}"></span>
                            SWE Data Source Status
                        </div>
                        <div>Latest Data Date: ${hasData ? data.latest_date : 'No Data Yet'}</div>
                        <div>Current Date: ${data.current_date || new Date().toISOString().split('T')[0]}</div>
                        <div>Data Lag: ${hasData && daysBehind !== null ? daysBehind : (hasData ? 'Calculating...' : 'N/A')} Days</div>
                        ${needsSync ? '<div style="color: #ed8936; margin-top: 10px;">‚ö†Ô∏è Data needs synchronization</div>' : '<div style="color: #48bb78; margin-top: 10px;">‚úÖ Data is up to date</div>'}
                        ${data.total_records !== undefined && data.total_records > 0 ? `<div style="margin-top: 8px; font-size: 0.9em; color: #718096;">Total Records: ${data.total_records.toLocaleString()}</div>` : ''}
                        ${data.source_statistics && Object.keys(data.source_statistics).length > 0 ? `
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e2e8f0;">
                                <div style="font-size: 0.85em; color: #4a5568; font-weight: bold; margin-bottom: 5px;">Data Source Statistics:</div>
                                ${Object.entries(data.source_statistics).map(([source, stats]) => `
                                    <div style="font-size: 0.8em; color: #718096; margin: 3px 0;">
                                        ${source}: ${stats.count || 0} Records, Latest Date: ${stats.latest_date || 'N/A'}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    `;
                    container.appendChild(statusCard);
                } else {
                    container.innerHTML = `<div class="alert alert-warning">${data.message || data.detail || 'Unable to get data source status'}</div>`;
                }
            } catch (error) {
                console.error('Failed to load data source status:', error);
                console.error('Error details:', error.message, error.stack);
                const container = document.getElementById('data-source-status');
                if (container) {
                    container.innerHTML = `
                        <div class="alert alert-warning">
                            <p>‚ö†Ô∏è Failed to load data source status</p>
                            <p style="font-size: 0.9em; margin-top: 10px;">Error: ${error.message || 'Network Error'}</p>
                            <p style="font-size: 0.85em; margin-top: 5px; color: #666;">
                                Please check:<br>
                                1. API endpoint /api/sync/status is available<br>
                                2. Server is running<br>
                                3. Network connection is normal
                            </p>
                        </div>
                    `;
                }
            }
        }

        // Sync all data sources
        async function syncAllDataSources(event = null) {
            console.log('üöÄ Starting data source synchronization...', event);

            const syncButton = event?.target || document.querySelector('button[onclick*="syncAllDataSources"]');
            const originalText = syncButton?.textContent || '';

            if (syncButton) {
                syncButton.disabled = true;
                syncButton.textContent = 'üîÑ Syncing...';
                console.log('‚úÖ Sync button disabled');
            } else {
                console.warn('‚ö†Ô∏è Could not find sync button');
            }

            showAlert('Synchronizing all data sources, this may take a few minutes...', 'warning');

            try {
                const response = await fetch('/api/sync/force-sync', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: `HTTP ${response.status}` }));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.status === 'success') {
                    const recordsAdded = data.records_added || 0;
                    const message = recordsAdded > 0
                        ? `‚úÖ Sync complete! Added ${recordsAdded} records. Latest data date: ${data.last_date_after || 'Unknown'}`
                        : data.message || '‚úÖ Sync complete (data is already up to date)';
                    showAlert(message, 'success');

                    // Refresh status immediately, then every 5 seconds for 30 seconds
                    refreshDataSourceStatus();
                    let refreshCount = 0;
                    const refreshInterval = setInterval(() => {
                        refreshDataSourceStatus();
                        refreshCount++;
                        if (refreshCount >= 6) { // 6 times * 5 seconds = 30 seconds
                            clearInterval(refreshInterval);
                        }
                    }, 5000);
                } else if (data.status === 'accepted') {
                    showAlert('Data source synchronization has started in the background, please refresh status later to view results', 'success');

                    // Wait for a while then start refreshing status
                    setTimeout(() => {
                        refreshDataSourceStatus();
                        let refreshCount = 0;
                        const refreshInterval = setInterval(() => {
                            refreshDataSourceStatus();
                            refreshCount++;
                            if (refreshCount >= 10) { // 10 times * 5 seconds = 50 seconds
                                clearInterval(refreshInterval);
                            }
                        }, 5000);
                    }, 5000);
                } else {
                    showAlert(`Data source synchronization failed: ${data.message || data.detail || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Failed to sync data sources:', error);
                showAlert(`Failed to sync data sources: ${error.message || 'Network error or server error'}`, 'error');
            } finally {
                if (syncButton) {
                    syncButton.disabled = false;
                    syncButton.textContent = originalText;
                }
            }
        }

        // Open data source settings
        function openDataSourceSettings() {
            const settingsHtml = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 800px; margin: 20px auto;">
                    <h2 style="margin-bottom: 20px;">Data Source Configuration</h2>
                    <div style="margin-bottom: 20px;">
                        <h3>Current Data Sources</h3>
                        <ul style="list-style: none; padding: 0;">
                            <li style="padding: 10px; background: #f7fafc; margin: 5px 0; border-radius: 5px;">
                                <strong>SWE Data:</strong> swe_data.db (SQLite Database)
                            </li>
                            <li style="padding: 10px; background: #f7fafc; margin: 5px 0; border-radius: 5px;">
                                <strong>Sync API:</strong> /api/sync/force-sync
                            </li>
                            <li style="padding: 10px; background: #f7fafc; margin: 5px 0; border-radius: 5px;">
                                <strong>Status Check:</strong> /api/sync/status
                            </li>
                        </ul>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <h3>Data Source Synchronization Instructions</h3>
                        <p>The system automatically synchronizes data from the following data sources:</p>
                        <ul>
                            <li>OpenMeteo: Meteorological data (temperature, precipitation, snow)</li>
                            <li>Manitoba Flood Warning System: Flood warning data</li>
                        </ul>
                        <p style="margin-top: 15px;">
                            <strong>Manual Sync:</strong> Click the "Sync All Data Sources" button to immediately trigger data synchronization.
                        </p>
                    </div>
                    <div style="text-align: right;">
                        <button class="btn" onclick="closeDataSourceSettings()">Close</button>
                    </div>
                </div>
            `;

            const overlay = document.createElement('div');
            overlay.id = 'data-source-settings-overlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;';
            overlay.innerHTML = settingsHtml;
            overlay.onclick = function (e) {
                if (e.target === overlay) {
                    closeDataSourceSettings();
                }
            };

            document.body.appendChild(overlay);
        }

        function closeDataSourceSettings() {
            const overlay = document.getElementById('data-source-settings-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Refresh all model status
        async function refreshAllModels() {
            showAlert('Refreshing model status...', 'warning');
            await loadModelsStatus();
            await loadSystemMetrics();
            await loadPerformanceChart(); // Reload performance chart
            await loadTrainingHistory(); // Reload training history
            await loadDriftDetection(); // Reload drift detection
            await loadFeatureImportance(); // Reload feature importance
            await loadCorrelationAnalysis(); // Reload correlation analysis
            showAlert('Model status refreshed', 'success');
        }

        // Load training history
        async function loadTrainingHistory() {
            try {
                const container = document.getElementById('training-history');
                if (!container) {
                    console.warn('Training history container not found');
                    return;
                }

                container.innerHTML = '<div style="text-align: center; padding: 20px; color: #718096;">Loading training history...</div>';

                // Get training history for all models
                const models = ['flood_prediction', 'water_quality_prediction'];
                let allHistory = [];

                for (const modelName of models) {
                    try {
                        const response = await fetch(`/api/training/models/${modelName}/performance`, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                            },
                        });
                        if (!response.ok) continue;

                        const data = await response.json();
                        if (data.performance_history && data.performance_history.length > 0) {
                            allHistory.push(...data.performance_history.map(h => ({
                                ...h,
                                model_name: modelName
                            })));
                        }
                    } catch (error) {
                        console.warn(`Failed to get training history for model ${modelName}:`, error);
                    }
                }

                // Sort by time
                allHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                if (allHistory.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #718096;">
                            <p>No training history records</p>
                            <p style="font-size: 0.9em; margin-top: 10px;">Please train models to view history</p>
                            <button class="btn btn-success" onclick="trainAllModels()" style="margin-top: 10px;">üöÄ Start Training</button>
                        </div>
                    `;
                    return;
                }

                // Display training history table
                const historyHtml = `
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                            <thead>
                                <tr style="background-color: #f7fafc; border-bottom: 2px solid #e2e8f0;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #2d3748;">Model</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: #2d3748;">Training Time</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748;">Accuracy</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748;">Precision</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748;">Recall</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748;">F1 Score</th>
                                    ${allHistory.some(h => h.rmse !== null) ? '<th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748;">RMSE</th>' : ''}
                                    ${allHistory.some(h => h.r2_score !== null) ? '<th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748;">R¬≤</th>' : ''}
                                </tr>
                            </thead>
                            <tbody>
                                ${allHistory.map((record, index) => {
                    const date = new Date(record.timestamp);
                    const dateStr = date.toLocaleString('en-US', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });

                    return `
                                        <tr style="border-bottom: 1px solid #e2e8f0; ${index % 2 === 0 ? 'background-color: #f9fafb;' : ''}">
                                            <td style="padding: 12px; color: #4a5568;">
                                                <span style="font-weight: 600;">${record.model_name || record.model_name || 'Unknown'}</span>
                                            </td>
                                            <td style="padding: 12px; color: #718096; font-size: 0.9em;">${dateStr}</td>
                                            <td style="padding: 12px; text-align: center;">
                                                <span style="color: ${(record.accuracy || 0) >= 0.8 ? '#48bb78' : (record.accuracy || 0) >= 0.6 ? '#ed8936' : '#f56565'}; font-weight: 600;">
                                                    ${((record.accuracy !== null && record.accuracy !== undefined) ? record.accuracy * 100 : 0).toFixed(1)}%
                                                </span>
                                            </td>
                                            <td style="padding: 12px; text-align: center; color: #4a5568;">
                                                ${((record.precision !== null && record.precision !== undefined) ? record.precision * 100 : 0).toFixed(1)}%
                                            </td>
                                            <td style="padding: 12px; text-align: center; color: #4a5568;">
                                                ${((record.recall !== null && record.recall !== undefined) ? record.recall * 100 : 0).toFixed(1)}%
                                            </td>
                                            <td style="padding: 12px; text-align: center; color: #4a5568;">
                                                ${((record.f1_score !== null && record.f1_score !== undefined) ? record.f1_score * 100 : 0).toFixed(1)}%
                                            </td>
                                            ${allHistory.some(h => h.rmse !== null) ? `
                                                <td style="padding: 12px; text-align: center; color: #4a5568;">
                                                    ${(record.rmse !== null && record.rmse !== undefined) ? record.rmse.toFixed(4) : 'N/A'}
                                                </td>
                                            ` : ''}
                                            ${allHistory.some(h => h.r2_score !== null) ? `
                                                <td style="padding: 12px; text-align: center; color: #4a5568;">
                                                    ${(record.r2_score !== null && record.r2_score !== undefined) ? record.r2_score.toFixed(4) : 'N/A'}
                                                </td>
                                            ` : ''}
                                        </tr>
                                    `;
                }).join('')}
                            </tbody>
                        </table>
                        <div style="margin-top: 15px; padding: 10px; background-color: #edf2f7; border-radius: 6px; font-size: 0.9em; color: #4a5568;">
                            <strong>Total:</strong> ${allHistory.length} records
                        </div>
                    </div>
                `;

                container.innerHTML = historyHtml;
                console.log('‚úÖ Training history loaded:', allHistory.length, 'records');

            } catch (error) {
                console.error('Failed to load training history:', error);
                const container = document.getElementById('training-history');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #f56565;">
                            <p>‚ùå Failed to load training history</p>
                            <p style="font-size: 0.9em; margin-top: 10px;">${error.message || 'Unknown Error'}</p>
                        </div>
                    `;
                }
            }
        }

        // Load correlation analysis (Phase 1 new feature)
        async function loadCorrelationAnalysis() {
            try {
                const container = document.getElementById('correlation-analysis');
                if (!container) {
                    console.warn('Correlation analysis container not found');
                    return;
                }

                container.innerHTML = '<div style="text-align: center; padding: 20px; color: #718096;">Loading correlation analysis...</div>';

                // Get correlation analysis (prioritize water quality prediction model, as it has more detailed correlation analysis)
                // If water quality prediction model is not available, use flood prediction model
                let response = await fetch('/api/training/models/water_quality_prediction/correlation-analysis', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });
                if (!response.ok || response.status === 404) {
                    // Fallback to flood prediction model
                    response = await fetch('/api/training/models/flood_prediction/correlation-analysis', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        },
                    });
                }
                if (!response.ok) {
                    if (response.status === 404) {
                        container.innerHTML = `
                            <div style="text-align: center; padding: 20px; color: #718096;">
                                <p>‚ö†Ô∏è Correlation Analysis API Not Found</p>
                                <p style="font-size: 0.9em; margin-top: 10px;">Server restart may be required to load new API routes</p>
                                <p style="font-size: 0.9em; margin-top: 5px;">Correlation analysis results saved in model performance metadata</p>
                            </div>
                        `;
                        return;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('üìä Correlation analysis data:', data);

                const correlationData = data.correlation_analysis;
                if (!correlationData) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #718096;">
                            <p>No correlation analysis data available</p>
                            <p style="font-size: 0.9em; margin-top: 10px;">Please train models to generate correlation analysis results</p>
                            <button class="btn btn-success" onclick="trainAllModels()" style="margin-top: 10px;">üöÄ Start Training</button>
                        </div>
                    `;
                    return;
                }

                // Display correlation analysis results
                let html = '<div style="padding: 15px;">';

                // Compatibility handling: supports new format (direct_correlations) and old format (strong_correlations)
                let directCorr = correlationData.direct_correlations || {};

                // If it's the old format (only strong_correlations), convert to new format
                if (!directCorr.strong_correlations && correlationData.strong_correlations) {
                    directCorr = {
                        'strong_correlations': correlationData.strong_correlations || [],
                        'moderate_correlations': correlationData.moderate_correlations || [],
                        'weak_correlations': correlationData.weak_correlations || [],
                        'strong_correlations_count': correlationData.strong_correlations_count || correlationData.strong_correlations?.length || 0,
                        'moderate_correlations_count': correlationData.moderate_correlations_count || correlationData.moderate_correlations?.length || 0,
                        'weak_correlations_count': correlationData.weak_correlations_count || correlationData.weak_correlations?.length || 0
                    };
                }
                if (directCorr.strong_correlations && directCorr.strong_correlations.length > 0) {
                    const strongList = directCorr.strong_correlations.map(corr =>
                        `<li style="margin-bottom: 8px; padding: 8px; background: #fed7d7; border-radius: 4px;">
                            <strong>${corr.feature1}</strong> ‚Üî <strong>${corr.feature2}</strong>
                            <span style="color: #e53e3e; font-weight: bold; margin-left: 10px;">r = ${corr.correlation.toFixed(3)}</span>
                        </li>`
                    ).join('');

                    html += `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #e53e3e; margin-bottom: 10px;">üìä Strong Correlations (${directCorr.strong_correlations.length})</h3>
                            <ul style="list-style: none; padding-left: 0;">
                                ${strongList}
                            </ul>
                        </div>
                    `;
                }

                // Moderate correlations - show more
                if (directCorr.moderate_correlations && directCorr.moderate_correlations.length > 0) {
                    const moderateList = directCorr.moderate_correlations.slice(0, 15).map(corr =>
                        `<li style="margin-bottom: 6px; font-size: 0.9em; padding: 6px; background: #feebc8; border-radius: 4px; border-left: 3px solid #f6ad55;">
                            <strong>${corr.feature1}</strong> ‚Üî <strong>${corr.feature2}</strong>
                            <span style="color: #d69e2e; margin-left: 10px; font-weight: 500;">r = ${corr.correlation.toFixed(3)}</span>
                            <span style="color: #c05621; margin-left: 5px; font-size: 0.85em;">(${corr.type === 'positive' ? 'Positive Correlation' : 'Negative Correlation'})</span>
                        </li>`
                    ).join('');

                    html += `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #d69e2e; margin-bottom: 10px;">üìà Moderate Correlations (${directCorr.moderate_correlations.length}, showing top 15)</h3>
                            <ul style="list-style: none; padding-left: 0;">
                                ${moderateList}
                            </ul>
                        </div>
                    `;
                }

                // Weak correlations - show more (because strong correlations might be common sense, weak correlations have more analytical value)
                if (directCorr.weak_correlations && directCorr.weak_correlations.length > 0) {
                    // Show top 20 weak correlations (because weak correlations might have more analytical value)
                    const weakList = directCorr.weak_correlations.slice(0, 20).map(corr =>
                        `<li style="margin-bottom: 6px; font-size: 0.9em; padding: 6px; background: #edf2f7; border-radius: 4px; border-left: 3px solid #cbd5e0;">
                            <strong>${corr.feature1}</strong> ‚Üî <strong>${corr.feature2}</strong>
                            <span style="color: #718096; margin-left: 10px; font-weight: 500;">r = ${corr.correlation.toFixed(3)}</span>
                            <span style="color: #a0aec0; margin-left: 5px; font-size: 0.85em;">(${corr.type === 'positive' ? 'Positive Correlation' : 'Negative Correlation'})</span>
                        </li>`
                    ).join('');

                    html += `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #718096; margin-bottom: 10px;">üìâ Weak Correlations (${directCorr.weak_correlations.length}, showing top 20)</h3>
                            <p style="color: #718096; font-size: 0.85em; margin-bottom: 10px;">
                                üí° Tip: Weak correlations may reveal hidden patterns, more valuable than obvious strong correlations
                            </p>
                            <ul style="list-style: none; padding-left: 0; max-height: 400px; overflow-y: auto;">
                                ${weakList}
                            </ul>
                        </div>
                    `;
                }

                // Causal relationships
                if (correlationData.causal_relationships_count > 0) {
                    html += `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #2d3748; margin-bottom: 10px;">üîó Causal Relationships</h3>
                            <p style="color: #4a5568; margin-bottom: 10px;">
                                Identified <strong>${correlationData.causal_relationships_count}</strong> causal relationships
                            </p>
                        </div>
                    `;
                }

                // Feature importance (based on causal relationships)
                if (correlationData.feature_importance && Object.keys(correlationData.feature_importance).length > 0) {
                    html += `
                        <div style="margin-bottom: 20px;">
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #2d3748; margin-bottom: 10px;">üìà Causal-based Feature Importance</h3>
                            <div style="background: #f7fafc; border-radius: 8px; padding: 15px;">
                                ${Object.entries(correlationData.feature_importance)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 10)
                            .map(([feature, importance]) => `
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                            <span style="color: #4a5568; font-size: 0.9em;">${feature}</span>
                                            <div style="flex: 1; margin: 0 15px;">
                                                <div style="background: #e2e8f0; height: 8px; border-radius: 4px; overflow: hidden;">
                                                    <div style="background: #667eea; height: 100%; width: ${importance * 100}%; transition: width 0.3s;"></div>
                                                </div>
                                            </div>
                                            <span style="color: #2d3748; font-weight: 600; font-size: 0.9em;">${(importance * 100).toFixed(1)}%</span>
                                        </div>
                                    `).join('')}
                            </div>
                        </div>
                    `;
                }

                if (!correlationData.strong_correlations_count && !correlationData.causal_relationships_count) {
                    html += `
                        <div style="text-align: center; padding: 20px; color: #718096;">
                            <p>Correlation analysis data is empty</p>
                            <p style="font-size: 0.9em; margin-top: 10px;">This may be because Bayesian network analysis was not executed or insufficient data</p>
                        </div>
                    `;
                }

                html += '</div>';
                container.innerHTML = html;
                console.log('‚úÖ Correlation analysis loaded');

            } catch (error) {
                console.error('Failed to load correlation analysis:', error);
                const container = document.getElementById('correlation-analysis');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #f56565;">
                            <p>‚ùå Failed to load correlation analysis</p>
                            <p style="font-size: 0.9em; margin-top: 10px;">${error.message || 'Unknown Error'}</p>
                            <button class="btn btn-success" onclick="loadCorrelationAnalysis()" style="margin-top: 10px;">üîÑ Retry</button>
                        </div>
                    `;
                }
            }
        }

        // Sync data and train all models (One-click execution)
        async function syncAndTrainAll() {
            const btn = document.getElementById('sync-and-train-btn');
            const originalText = btn?.textContent || '';

            if (btn) {
                btn.disabled = true;
                btn.textContent = '‚è≥ Syncing data...';
            }

            showAlert('üîÑ Starting: 1. Sync Data Sources ‚Üí 2. Train Models', 'warning');

            try {
                // Step 1: Sync Data
                console.log('üì• Step 1: Syncing data sources...');
                const syncResponse = await fetch('/api/sync/force-sync', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!syncResponse.ok) {
                    throw new Error(`Data sync failed: HTTP ${syncResponse.status}`);
                }

                const syncData = await syncResponse.json();
                console.log('‚úÖ Data sync result:', syncData);

                if (btn) {
                    btn.textContent = '‚è≥ Training models...';
                }

                // Wait for data to be written to DB
                await new Promise(resolve => setTimeout(resolve, 2000));

                // Refresh data source status
                await refreshDataSourceStatus();

                // Step 2: Train Models
                console.log('üöÄ Step 2: Starting model training...');
                const models = Object.keys(modelStatusData.models || {});

                if (models.length === 0) {
                    // If no models, refresh status first
                    await loadModelsStatus();
                    const updatedModels = Object.keys(modelStatusData.models || {});
                    if (updatedModels.length === 0) {
                        throw new Error('No models available for training');
                    }
                    models.push(...updatedModels);
                }

                const trainPromises = models.map(modelName =>
                    fetch(`/api/training/models/${modelName}/train?force_retrain=true`, {
                        method: 'POST'
                    }).then(async r => {
                        const data = await r.json().catch(() => ({}));
                        return { model: modelName, status: r.status, data };
                    })
                );

                const trainResults = await Promise.all(trainPromises);
                console.log('‚úÖ Training results:', trainResults);

                const successCount = trainResults.filter(r => r.status === 200 || r.status === 202).length;

                showAlert(
                    `‚úÖ Complete! Data Sync: ${syncData.records_added || 0} records, Model Training: ${successCount}/${models.length} models started`,
                    'success'
                );

                // Refresh status
                setTimeout(() => {
                    refreshAllModels();
                    refreshDataSourceStatus();
                    // Ensure performance chart also refreshes
                    loadPerformanceChart();
                }, 3000);

            } catch (error) {
                console.error('Sync and train failed:', error);
                showAlert(`‚ùå Execution failed: ${error.message || 'Unknown error'}`, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            }
        }

        // Train all models
        async function trainAllModels() {
            showAlert('Starting model training...', 'warning');

            try {
                const models = Object.keys(modelStatusData.models || {});

                if (models.length === 0) {
                    // If no models, refresh status first
                    await loadModelsStatus();
                    const updatedModels = Object.keys(modelStatusData.models || {});
                    if (updatedModels.length === 0) {
                        showAlert('‚ùå No models available for training. Please check if the model training module is available.', 'error');
                        return;
                    }
                    models.push(...updatedModels);
                }

                const promises = models.map(modelName =>
                    fetch(`/api/training/models/${modelName}/train?force_retrain=true`, {
                        method: 'POST'
                    })
                );

                const results = await Promise.allSettled(promises);
                const successCount = results.filter(r => r.status === 'fulfilled').length;

                if (successCount > 0) {
                    showAlert(`‚úÖ ${successCount}/${models.length} model training started`, 'success');
                } else {
                    showAlert('‚ùå All model training failed to start', 'error');
                }

                // Wait for a while then refresh status
                setTimeout(() => {
                    refreshAllModels();
                }, 5000);
            } catch (error) {
                console.error('Failed to start training:', error);
                showAlert(`‚ùå Failed to start training: ${error.message || 'Unknown error'}`, 'error');
            }
        }

        // Detect all data drift
        async function detectAllDrift() {
            showAlert('Detecting data drift...', 'warning');

            try {
                const models = Object.keys(modelStatusData.models || {});
                const promises = models.map(modelName =>
                    fetch(`/api/training/models/${modelName}/detect-drift`, {
                        method: 'POST'
                    })
                );

                await Promise.all(promises);
                showAlert('Data drift detection started', 'success');

                // Wait for a while then refresh drift detection results
                setTimeout(() => {
                    loadDriftDetection();
                }, 5000);
            } catch (error) {
                console.error('Failed to detect data drift:', error);
                showAlert('Failed to detect data drift', 'error');
            }
        }

        // Load data drift detection results
        async function loadDriftDetection() {
            try {
                const response = await fetch('/api/training/models/flood_prediction/data-drift', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });

                if (!response.ok) {
                    if (response.status === 404) {
                        // Return empty data on 404
                        const container = document.getElementById('drift-detection');
                        container.innerHTML = '<p style="padding: 15px; color: #718096;">No data drift detection results yet. Drift detection cannot be performed if the model is not trained.</p>';
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                const container = document.getElementById('drift-detection');

                if (data.drift_info && data.drift_info.length > 0) {
                    container.innerHTML = `
                        <div class="drift-detection">
                            <h4>Drift Detection Results (${data.drift_detection_timestamp || new Date().toLocaleString()})</h4>
                            ${data.drift_info.map(drift => `
                                <div class="drift-item">
                                    <span>${drift.feature_name}</span>
                                    <span class="drift-score ${drift.is_significant ? 'drift-high' : 'drift-low'}">
                                        ${(drift.drift_score * 100).toFixed(1)}%
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else {
                    container.innerHTML = `<p style="padding: 15px; color: #718096;">${data.message || 'No data drift detection results yet. Please train the model and perform drift detection first.'}</p>`;
                }
            } catch (error) {
                console.error('Failed to load data drift detection results:', error);
                const container = document.getElementById('drift-detection');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 15px; color: #ed8936; background: #fff5f5; border-radius: 8px; border-left: 4px solid #ed8936;">
                            <p style="font-weight: 600; margin-bottom: 5px;">‚ö†Ô∏è Unable to load data drift detection results</p>
                            <p style="font-size: 0.9em; margin-top: 5px;">Error: ${error.message || 'Network Error'}</p>
                            <p style="font-size: 0.85em; margin-top: 5px; color: #666;">
                                Please check:<br>
                                1. Server is running<br>
                                2. API endpoints are available<br>
                                3. Network connection is normal
                            </p>
                        </div>
                    `;
                }
            }
        }

        // Load feature importance
        async function loadFeatureImportance() {
            try {
                const response = await fetch('/api/training/models/flood_prediction/feature-importance', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                });

                if (!response.ok) {
                    if (response.status === 404) {
                        // Return empty data on 404
                        const container = document.getElementById('feature-importance');
                        container.innerHTML = '<p style="padding: 15px; color: #718096;">No feature importance data yet. Feature importance cannot be displayed if the model is not trained.</p>';
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                const container = document.getElementById('feature-importance');

                if (data.feature_importance && Object.keys(data.feature_importance).length > 0) {
                    const features = Object.entries(data.feature_importance)
                        .sort(([, a], [, b]) => b - a)
                        .slice(0, 10); // Only show the top 10 most important features

                    container.innerHTML = `
                        <div class="feature-importance">
                            ${features.map(([feature, importance]) => `
                                <div class="feature-item">
                                    <span>${feature.replace(/_/g, ' ')}</span>
                                    <div class="feature-bar">
                                        <div class="feature-fill" style="width: ${(importance * 100).toFixed(1)}%"></div>
                                    </div>
                                    <span>${(importance * 100).toFixed(1)}%</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else {
                    container.innerHTML = `<p style="padding: 15px; color: #718096;">${data.message || 'No feature importance data yet. Please train the model first.'}</p>`;
                }
            } catch (error) {
                console.error('Failed to load feature importance:', error);
                const container = document.getElementById('feature-importance');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 15px; color: #ed8936; background: #fff5f5; border-radius: 8px; border-left: 4px solid #ed8936;">
                            <p style="font-weight: 600; margin-bottom: 5px;">‚ö†Ô∏è Unable to load feature importance data</p>
                            <p style="font-size: 0.9em; margin-top: 5px;">Error: ${error.message || 'Network Error'}</p>
                            <p style="font-size: 0.85em; margin-top: 5px; color: #666;">
                                Please check:<br>
                                1. Server is running<br>
                                2. API endpoints are available<br>
                                3. Network connection is normal
                            </p>
                        </div>
                    `;
                }
            }
        }

        // Export performance report
        function exportPerformanceReport() {
            const reportData = {
                timestamp: new Date().toISOString(),
                system_health: systemHealth,
                models_status: modelStatusData,
                report_type: 'model_training_performance'
            };

            const blob = new Blob([JSON.stringify(reportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `model_training_report_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showAlert('Performance report exported', 'success');
        }

        // Refresh dashboard
        async function refreshDashboard() {
            await loadModelsStatus();
            await loadSystemMetrics();
            await loadDriftDetection();
            await loadFeatureImportance();
            await loadCorrelationAnalysis(); // Load correlation analysis (Phase 1 new feature)
            await checkSystemHealth();
        }

        // Update status timestamp
        function updateStatusTimestamp() {
            document.getElementById('status-timestamp').textContent =
                `Last Updated: ${new Date().toLocaleString()}`;
        }

        // Show alert message
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;

            // Insert before the first card
            const container = document.querySelector('.container');
            const firstCard = container.querySelector('.card');
            container.insertBefore(alertDiv, firstCard);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.parentNode.removeChild(alertDiv);
                }
            }, 3000);
        }
    </script>
</body>

</html>
```