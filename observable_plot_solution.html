<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ“Š Observable Plot ç°ä»£åŒ–è§£å†³æ–¹æ¡ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .chart-section { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .plot-container { margin: 20px 0; }
        .interpretation { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 15px 0; }
    </style>
</head>
<body>
    <h1>ğŸ“Š Observable Plot ç°ä»£åŒ–å›¾è¡¨è§£å†³æ–¹æ¡ˆ</h1>
    
    <div class="chart-section">
        <h2>èšç±»åˆ†æå›¾è¡¨</h2>
        <div id="clustering-plot" class="plot-container"></div>
        <div id="clustering-interpretation" class="interpretation"></div>
    </div>

    <div class="chart-section">
        <h2>å¼‚å¸¸æ£€æµ‹å›¾è¡¨</h2>
        <div id="anomaly-plot" class="plot-container"></div>
        <div id="anomaly-interpretation" class="interpretation"></div>
    </div>

    <div class="chart-section">
        <h2>å› å­é‡è¦æ€§å›¾è¡¨</h2>
        <div id="factors-plot" class="plot-container"></div>
        <div id="factors-interpretation" class="interpretation"></div>
    </div>

    <script>
        async function loadAndCreatePlots() {
            try {
                // åŠ è½½èšç±»æ•°æ®å¹¶åˆ›å»ºå›¾è¡¨
                const clusteringResp = await fetch('/api/v1/data-science/clustering');
                const clusteringData = await clusteringResp.json();
                if (clusteringData.success) {
                    createClusteringPlot(clusteringData.results);
                }

                // åŠ è½½å¼‚å¸¸æ£€æµ‹æ•°æ®å¹¶åˆ›å»ºå›¾è¡¨
                const anomalyResp = await fetch('/api/v1/data-science/anomaly-detection?column=snow_water_equivalent_mm');
                const anomalyData = await anomalyResp.json();
                if (anomalyData.success) {
                    createAnomalyPlot(anomalyData.results);
                }

                // åŠ è½½å› å­å‘ç°æ•°æ®å¹¶åˆ›å»ºå›¾è¡¨
                const factorsResp = await fetch('/api/v1/data-science/factor-discovery?target=snow_water_equivalent_mm&top_k=10');
                const factorsData = await factorsResp.json();
                if (factorsData.success) {
                    createFactorsPlot(factorsData.results);
                }

            } catch (error) {
                console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
            }
        }

        function createClusteringPlot(results) {
            // å¤„ç†èšç±»æ•°æ®
            const labels = results.kmeans.labels || [];
            const counts = {};
            labels.forEach(l => { const k = String(l); counts[k] = (counts[k]||0)+1; });
            
            const data = Object.keys(counts).sort().map(key => ({
                cluster: `èšç±» ${key}`,
                count: counts[key]
            }));

            const plot = Plot.plot({
                title: `K-meansèšç±»åˆ†å¸ƒ (è½®å»“åˆ†æ•°: ${results.kmeans.silhouette_score.toFixed(3)})`,
                width: 600,
                height: 400,
                marginBottom: 60,
                x: {
                    label: "èšç±»"
                },
                y: {
                    label: "æ•°æ®ç‚¹æ•°é‡"
                },
                marks: [
                    Plot.barY(data, {
                        x: "cluster",
                        y: "count",
                        fill: "#2ecc71",
                        tip: true
                    }),
                    Plot.text(data, {
                        x: "cluster",
                        y: "count",
                        text: "count",
                        dy: -10,
                        fontSize: 12
                    })
                ]
            });

            document.getElementById('clustering-plot').appendChild(plot);

            // æ˜¾ç¤ºè§£è¯»
            if (results.interpretation) {
                displayInterpretation('clustering-interpretation', results.interpretation, 'ğŸŒ èšç±»åˆ†æè§£è¯»');
            }
        }

        function createAnomalyPlot(results) {
            const ensemble = results.ensemble;
            const scores = ensemble.ensemble_scores || [];
            const anomalies = ensemble.ensemble_anomalies || [];
            const threshold = ensemble.threshold || 2.0;

            // å‡†å¤‡æ•°æ®
            const data = scores.map((score, i) => ({
                index: i,
                score: score,
                isAnomaly: anomalies[i],
                threshold: threshold
            }));

            const plot = Plot.plot({
                title: "å¼‚å¸¸æ£€æµ‹ç»“æœ",
                width: 800,
                height: 400,
                x: {
                    label: "æ•°æ®ç´¢å¼•"
                },
                y: {
                    label: "å¼‚å¸¸åˆ†æ•°"
                },
                marks: [
                    // æ­£å¸¸ç‚¹çš„çº¿æ¡
                    Plot.line(data.filter(d => !d.isAnomaly), {
                        x: "index",
                        y: "score",
                        stroke: "#34495e",
                        strokeWidth: 2
                    }),
                    // å¼‚å¸¸ç‚¹
                    Plot.dot(data.filter(d => d.isAnomaly), {
                        x: "index",
                        y: "score",
                        fill: "#e74c3c",
                        r: 4,
                        tip: true
                    }),
                    // é˜ˆå€¼çº¿
                    Plot.ruleY([threshold], {
                        stroke: "#e67e22",
                        strokeDasharray: "5,5",
                        strokeWidth: 2
                    }),
                    // é˜ˆå€¼æ ‡ç­¾
                    Plot.text([{threshold: threshold}], {
                        x: data.length * 0.9,
                        y: "threshold",
                        text: d => `é˜ˆå€¼: ${d.threshold}`,
                        fill: "#e67e22",
                        fontSize: 12
                    })
                ]
            });

            document.getElementById('anomaly-plot').appendChild(plot);

            // æ˜¾ç¤ºè§£è¯»
            if (results.interpretation) {
                document.getElementById('anomaly-interpretation').innerHTML = 
                    `<h4>ğŸš¨ å¼‚å¸¸æ£€æµ‹è§£è¯»</h4><p>${results.interpretation}</p>`;
            }
        }

        function createFactorsPlot(results) {
            const factors = results.high_predictive || [];
            
            const data = factors.map(f => ({
                factor: f.factor,
                score: f.score
            }));

            const plot = Plot.plot({
                title: "é‡è¦å› å­å‘ç°",
                width: 700,
                height: 400,
                marginLeft: 120,
                x: {
                    label: "é‡è¦æ€§åˆ†æ•°"
                },
                y: {
                    label: "å› å­"
                },
                marks: [
                    Plot.barX(data, {
                        y: "factor",
                        x: "score",
                        fill: "#f39c12",
                        tip: true
                    }),
                    Plot.text(data, {
                        y: "factor",
                        x: "score",
                        text: d => d.score.toFixed(3),
                        dx: 10,
                        fontSize: 11
                    })
                ]
            });

            document.getElementById('factors-plot').appendChild(plot);

            // æ˜¾ç¤ºè§£è¯»
            if (results.interpretation) {
                document.getElementById('factors-interpretation').innerHTML = 
                    `<h4>ğŸ” å› å­å‘ç°è§£è¯»</h4><p>${results.interpretation}</p>`;
            }
        }

        function displayInterpretation(containerId, interpretation, title) {
            let html = `<h4>${title}</h4>`;
            
            if (interpretation.summary) {
                html += `<p><strong>æ‘˜è¦:</strong> ${interpretation.summary}</p>`;
            }
            
            if (interpretation.key_insights && interpretation.key_insights.length > 0) {
                html += '<p><strong>å…³é”®æ´å¯Ÿ:</strong></p><ul>';
                interpretation.key_insights.forEach(insight => {
                    html += `<li>${insight}</li>`;
                });
                html += '</ul>';
            }
            
            if (interpretation.business_implications) {
                html += `<p><strong>ä¸šåŠ¡å½±å“:</strong> ${interpretation.business_implications}</p>`;
            }
            
            if (interpretation.recommendations && interpretation.recommendations.length > 0) {
                html += '<p><strong>å»ºè®®:</strong></p><ul>';
                interpretation.recommendations.forEach(rec => {
                    html += `<li>${rec}</li>`;
                });
                html += '</ul>';
            }
            
            document.getElementById(containerId).innerHTML = html;
        }

        // é¡µé¢åŠ è½½ååˆ›å»ºå›¾è¡¨
        document.addEventListener('DOMContentLoaded', loadAndCreatePlots);
    </script>
</body>
</html>









