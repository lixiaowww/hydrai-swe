<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¨ Canvas åŸç”Ÿè§£å†³æ–¹æ¡ˆ</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .chart-section { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .canvas-container { position: relative; margin: 20px 0; }
        canvas { border: 1px solid #ccc; cursor: crosshair; }
        .interpretation { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 15px 0; }
        .chart-info { margin: 10px 0; font-size: 14px; color: #666; }
    </style>
</head>
<body>
    <h1>ğŸ¨ Canvas åŸç”Ÿå›¾è¡¨è§£å†³æ–¹æ¡ˆ</h1>
    
    <div class="chart-section">
        <h2>èšç±»åˆ†æå›¾è¡¨</h2>
        <div class="canvas-container">
            <canvas id="clustering-canvas" width="800" height="400"></canvas>
            <div class="chart-info">é¼ æ ‡æ‚¬åœæŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</div>
        </div>
        <div id="clustering-interpretation" class="interpretation"></div>
    </div>

    <div class="chart-section">
        <h2>å¼‚å¸¸æ£€æµ‹å›¾è¡¨</h2>
        <div class="canvas-container">
            <canvas id="anomaly-canvas" width="800" height="400"></canvas>
            <div class="chart-info">çº¢è‰²ç‚¹ä¸ºå¼‚å¸¸å€¼</div>
        </div>
        <div id="anomaly-interpretation" class="interpretation"></div>
    </div>

    <div class="chart-section">
        <h2>å› å­é‡è¦æ€§å›¾è¡¨</h2>
        <div class="canvas-container">
            <canvas id="factors-canvas" width="800" height="400"></canvas>
            <div class="chart-info">æ¨ªå‘æ¡å½¢å›¾æ˜¾ç¤ºé‡è¦æ€§</div>
        </div>
        <div id="factors-interpretation" class="interpretation"></div>
    </div>

    <script>
        class CanvasChart {
            constructor(canvasId, width = 800, height = 400) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = width;
                this.height = height;
                this.padding = { top: 40, right: 40, bottom: 60, left: 80 };
                
                // æ·»åŠ é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseout', () => this.onMouseOut());
            }

            clear() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }

            drawBarChart(data, title, xLabel, yLabel) {
                this.clear();
                
                const chartWidth = this.width - this.padding.left - this.padding.right;
                const chartHeight = this.height - this.padding.top - this.padding.bottom;
                
                // ç»˜åˆ¶æ ‡é¢˜
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, this.width / 2, 25);
                
                // ç»˜åˆ¶åæ ‡è½´
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                // Yè½´
                this.ctx.moveTo(this.padding.left, this.padding.top);
                this.ctx.lineTo(this.padding.left, this.height - this.padding.bottom);
                // Xè½´
                this.ctx.lineTo(this.width - this.padding.right, this.height - this.padding.bottom);
                this.ctx.stroke();
                
                // è®¡ç®—æ•°æ®èŒƒå›´
                const maxValue = Math.max(...data.map(d => d.value));
                const barWidth = chartWidth / data.length * 0.8;
                const barSpacing = chartWidth / data.length * 0.2;
                
                // ç»˜åˆ¶æ¡å½¢
                data.forEach((item, index) => {
                    const barHeight = (item.value / maxValue) * chartHeight;
                    const x = this.padding.left + index * (barWidth + barSpacing) + barSpacing / 2;
                    const y = this.height - this.padding.bottom - barHeight;
                    
                    // æ¸å˜å¡«å……
                    const gradient = this.ctx.createLinearGradient(0, y, 0, y + barHeight);
                    gradient.addColorStop(0, '#2ecc71');
                    gradient.addColorStop(1, '#27ae60');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // ç»˜åˆ¶è¾¹æ¡†
                    this.ctx.strokeStyle = '#1e8449';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(x, y, barWidth, barHeight);
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(item.label, x + barWidth / 2, this.height - this.padding.bottom + 20);
                    
                    // ç»˜åˆ¶æ•°å€¼
                    this.ctx.fillText(item.value.toString(), x + barWidth / 2, y - 5);
                });
                
                // ç»˜åˆ¶Yè½´æ ‡ç­¾
                this.ctx.save();
                this.ctx.translate(15, this.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillStyle = '#333';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(yLabel, 0, 0);
                this.ctx.restore();
                
                // ç»˜åˆ¶Xè½´æ ‡ç­¾
                this.ctx.fillStyle = '#333';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(xLabel, this.width / 2, this.height - 5);
            }

            drawLineChart(data, title, anomalies = []) {
                this.clear();
                
                const chartWidth = this.width - this.padding.left - this.padding.right;
                const chartHeight = this.height - this.padding.top - this.padding.bottom;
                
                // ç»˜åˆ¶æ ‡é¢˜
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, this.width / 2, 25);
                
                // ç»˜åˆ¶åæ ‡è½´
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding.left, this.padding.top);
                this.ctx.lineTo(this.padding.left, this.height - this.padding.bottom);
                this.ctx.lineTo(this.width - this.padding.right, this.height - this.padding.bottom);
                this.ctx.stroke();
                
                if (data.length === 0) return;
                
                // è®¡ç®—æ•°æ®èŒƒå›´
                const maxValue = Math.max(...data);
                const minValue = Math.min(...data);
                const range = maxValue - minValue;
                
                // ç»˜åˆ¶çº¿æ¡
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                data.forEach((value, index) => {
                    const x = this.padding.left + (index / (data.length - 1)) * chartWidth;
                    const y = this.height - this.padding.bottom - ((value - minValue) / range) * chartHeight;
                    
                    if (index === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
                
                // ç»˜åˆ¶å¼‚å¸¸ç‚¹
                anomalies.forEach((isAnomaly, index) => {
                    if (isAnomaly) {
                        const x = this.padding.left + (index / (data.length - 1)) * chartWidth;
                        const y = this.height - this.padding.bottom - ((data[index] - minValue) / range) * chartHeight;
                        
                        this.ctx.fillStyle = '#e74c3c';
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                });
            }

            drawHorizontalBarChart(data, title) {
                this.clear();
                
                const chartWidth = this.width - this.padding.left - this.padding.right;
                const chartHeight = this.height - this.padding.top - this.padding.bottom;
                
                // ç»˜åˆ¶æ ‡é¢˜
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, this.width / 2, 25);
                
                if (data.length === 0) return;
                
                const maxValue = Math.max(...data.map(d => d.value));
                const barHeight = chartHeight / data.length * 0.8;
                const barSpacing = chartHeight / data.length * 0.2;
                
                data.forEach((item, index) => {
                    const barWidth = (item.value / maxValue) * chartWidth;
                    const x = this.padding.left;
                    const y = this.padding.top + index * (barHeight + barSpacing) + barSpacing / 2;
                    
                    // æ¸å˜å¡«å……
                    const gradient = this.ctx.createLinearGradient(x, 0, x + barWidth, 0);
                    gradient.addColorStop(0, '#f39c12');
                    gradient.addColorStop(1, '#e67e22');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(item.label, this.padding.left - 10, y + barHeight / 2 + 4);
                    
                    // ç»˜åˆ¶æ•°å€¼
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(item.value.toFixed(3), x + barWidth + 5, y + barHeight / 2 + 4);
                });
            }

            onMouseMove(event) {
                // é¼ æ ‡æ‚¬åœæ•ˆæœå¯ä»¥åœ¨è¿™é‡Œå®ç°
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šäº¤äº’æ•ˆæœ
            }

            onMouseOut() {
                // é¼ æ ‡ç§»å‡ºæ•ˆæœ
            }
        }

        async function loadAndDisplayCharts() {
            try {
                // åˆ›å»ºå›¾è¡¨å®ä¾‹
                const clusteringChart = new CanvasChart('clustering-canvas');
                const anomalyChart = new CanvasChart('anomaly-canvas');
                const factorsChart = new CanvasChart('factors-canvas');

                // åŠ è½½èšç±»æ•°æ®
                const clusteringResp = await fetch('/api/v1/data-science/clustering');
                const clusteringData = await clusteringResp.json();
                if (clusteringData.success) {
                    const results = clusteringData.results;
                    const labels = results.kmeans.labels || [];
                    const counts = {};
                    labels.forEach(l => { const k = String(l); counts[k] = (counts[k]||0)+1; });
                    
                    const chartData = Object.keys(counts).sort().map(key => ({
                        label: `èšç±» ${key}`,
                        value: counts[key]
                    }));
                    
                    clusteringChart.drawBarChart(
                        chartData, 
                        `K-meansèšç±»åˆ†å¸ƒ (è½®å»“åˆ†æ•°: ${results.kmeans.silhouette_score.toFixed(3)})`,
                        'èšç±»ID',
                        'æ•°æ®ç‚¹æ•°é‡'
                    );
                    
                    if (results.interpretation) {
                        displayInterpretation('clustering-interpretation', results.interpretation, 'ğŸŒ èšç±»åˆ†æè§£è¯»');
                    }
                }

                // åŠ è½½å¼‚å¸¸æ£€æµ‹æ•°æ®
                const anomalyResp = await fetch('/api/v1/data-science/anomaly-detection?column=snow_water_equivalent_mm');
                const anomalyData = await anomalyResp.json();
                if (anomalyData.success) {
                    const results = anomalyData.results;
                    const scores = results.ensemble.ensemble_scores || [];
                    const anomalies = results.ensemble.ensemble_anomalies || [];
                    
                    anomalyChart.drawLineChart(scores, 'å¼‚å¸¸æ£€æµ‹åˆ†æ•°', anomalies);
                    
                    if (results.interpretation) {
                        document.getElementById('anomaly-interpretation').innerHTML = 
                            `<h4>ğŸš¨ å¼‚å¸¸æ£€æµ‹è§£è¯»</h4><p>${results.interpretation}</p>`;
                    }
                }

                // åŠ è½½å› å­å‘ç°æ•°æ®
                const factorsResp = await fetch('/api/v1/data-science/factor-discovery?target=snow_water_equivalent_mm&top_k=10');
                const factorsData = await factorsResp.json();
                if (factorsData.success) {
                    const results = factorsData.results;
                    const factors = results.high_predictive || [];
                    
                    const chartData = factors.map(f => ({
                        label: f.factor,
                        value: f.score
                    }));
                    
                    factorsChart.drawHorizontalBarChart(chartData, 'é‡è¦å› å­å‘ç°');
                    
                    if (results.interpretation) {
                        document.getElementById('factors-interpretation').innerHTML = 
                            `<h4>ğŸ” å› å­å‘ç°è§£è¯»</h4><p>${results.interpretation}</p>`;
                    }
                }

            } catch (error) {
                console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
            }
        }

        function displayInterpretation(containerId, interpretation, title) {
            let html = `<h4>${title}</h4>`;
            
            if (interpretation.summary) {
                html += `<p><strong>æ‘˜è¦:</strong> ${interpretation.summary}</p>`;
            }
            
            if (interpretation.key_insights && interpretation.key_insights.length > 0) {
                html += '<p><strong>å…³é”®æ´å¯Ÿ:</strong></p><ul>';
                interpretation.key_insights.forEach(insight => {
                    html += `<li>${insight}</li>`;
                });
                html += '</ul>';
            }
            
            if (interpretation.business_implications) {
                html += `<p><strong>ä¸šåŠ¡å½±å“:</strong> ${interpretation.business_implications}</p>`;
            }
            
            if (interpretation.recommendations && interpretation.recommendations.length > 0) {
                html += '<p><strong>å»ºè®®:</strong></p><ul>';
                interpretation.recommendations.forEach(rec => {
                    html += `<li>${rec}</li>`;
                });
                html += '</ul>';
            }
            
            document.getElementById(containerId).innerHTML = html;
        }

        // é¡µé¢åŠ è½½ååˆ›å»ºå›¾è¡¨
        document.addEventListener('DOMContentLoaded', loadAndDisplayCharts);
    </script>
</body>
</html>









