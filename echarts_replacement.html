<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš€ ECharts æ›¿ä»£æ–¹æ¡ˆæµ‹è¯•</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .chart-container { width: 100%; height: 400px; margin: 20px 0; border: 1px solid #ddd; }
        .interpretation { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>ğŸš€ ECharts æ›¿ä»£æ–¹æ¡ˆ - æ— å†²çªå›¾è¡¨åº“</h1>
    
    <div id="clustering-chart" class="chart-container"></div>
    <div id="clustering-interpretation" class="interpretation"></div>
    
    <div id="anomaly-chart" class="chart-container"></div>
    <div id="anomaly-interpretation" class="interpretation"></div>
    
    <div id="factors-chart" class="chart-container"></div>
    <div id="factors-interpretation" class="interpretation"></div>

    <script>
        async function loadDataAndCreateCharts() {
            try {
                // åŠ è½½èšç±»æ•°æ®
                const clusteringResp = await fetch('/api/v1/data-science/clustering');
                const clusteringData = await clusteringResp.json();
                if (clusteringData.success) {
                    createClusteringChart(clusteringData.results);
                }

                // åŠ è½½å¼‚å¸¸æ£€æµ‹æ•°æ®
                const anomalyResp = await fetch('/api/v1/data-science/anomaly-detection?column=snow_water_equivalent_mm');
                const anomalyData = await anomalyResp.json();
                if (anomalyData.success) {
                    createAnomalyChart(anomalyData.results);
                }

                // åŠ è½½å› å­å‘ç°æ•°æ®
                const factorsResp = await fetch('/api/v1/data-science/factor-discovery?target=snow_water_equivalent_mm&top_k=10');
                const factorsData = await factorsResp.json();
                if (factorsData.success) {
                    createFactorsChart(factorsData.results);
                }

            } catch (error) {
                console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
            }
        }

        function createClusteringChart(results) {
            const chartDom = document.getElementById('clustering-chart');
            const myChart = echarts.init(chartDom);

            // å¤„ç†èšç±»æ•°æ®
            const labels = results.kmeans.labels || [];
            const counts = {};
            labels.forEach(l => { const k = String(l); counts[k] = (counts[k]||0)+1; });
            
            const categories = Object.keys(counts).sort();
            const values = categories.map(k => counts[k]);

            const option = {
                title: {
                    text: `K-meansèšç±»åˆ†å¸ƒ (è½®å»“åˆ†æ•°: ${results.kmeans.silhouette_score.toFixed(3)})`,
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' }
                },
                xAxis: {
                    type: 'category',
                    data: categories.map(c => `èšç±» ${c}`)
                },
                yAxis: {
                    type: 'value',
                    name: 'æ•°æ®ç‚¹æ•°é‡'
                },
                series: [{
                    name: 'èšç±»å¤§å°',
                    type: 'bar',
                    data: values,
                    itemStyle: {
                        color: '#2ecc71'
                    },
                    label: {
                        show: true,
                        position: 'top'
                    }
                }]
            };

            myChart.setOption(option);

            // æ˜¾ç¤ºè§£è¯»
            if (results.interpretation) {
                displayInterpretation('clustering-interpretation', results.interpretation, 'ğŸŒ èšç±»åˆ†æè§£è¯»');
            }
        }

        function createAnomalyChart(results) {
            const chartDom = document.getElementById('anomaly-chart');
            const myChart = echarts.init(chartDom);

            const ensemble = results.ensemble;
            const scores = ensemble.ensemble_scores || [];
            const anomalies = ensemble.ensemble_anomalies || [];
            const threshold = ensemble.threshold || 2.0;

            const xData = Array.from({length: scores.length}, (_, i) => i);
            const normalScores = scores.map((score, i) => anomalies[i] ? null : score);
            const anomalyScores = scores.map((score, i) => anomalies[i] ? score : null);

            const option = {
                title: {
                    text: 'å¼‚å¸¸æ£€æµ‹ç»“æœ',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis'
                },
                legend: {
                    data: ['æ­£å¸¸åˆ†æ•°', 'å¼‚å¸¸ç‚¹', 'é˜ˆå€¼çº¿'],
                    top: 30
                },
                xAxis: {
                    type: 'category',
                    data: xData,
                    name: 'æ•°æ®ç´¢å¼•'
                },
                yAxis: {
                    type: 'value',
                    name: 'å¼‚å¸¸åˆ†æ•°'
                },
                series: [
                    {
                        name: 'æ­£å¸¸åˆ†æ•°',
                        type: 'line',
                        data: normalScores,
                        itemStyle: { color: '#34495e' },
                        symbol: 'none'
                    },
                    {
                        name: 'å¼‚å¸¸ç‚¹',
                        type: 'scatter',
                        data: anomalyScores,
                        itemStyle: { color: '#e74c3c' },
                        symbolSize: 6
                    },
                    {
                        name: 'é˜ˆå€¼çº¿',
                        type: 'line',
                        data: Array(scores.length).fill(threshold),
                        itemStyle: { color: '#e67e22' },
                        lineStyle: { type: 'dashed' },
                        symbol: 'none'
                    }
                ]
            };

            myChart.setOption(option);

            // æ˜¾ç¤ºè§£è¯»
            if (results.interpretation) {
                document.getElementById('anomaly-interpretation').innerHTML = 
                    `<h4>ğŸš¨ å¼‚å¸¸æ£€æµ‹è§£è¯»</h4><p>${results.interpretation}</p>`;
            }
        }

        function createFactorsChart(results) {
            const chartDom = document.getElementById('factors-chart');
            const myChart = echarts.init(chartDom);

            const factors = results.high_predictive || [];
            const names = factors.map(f => f.factor);
            const scores = factors.map(f => f.score);

            const option = {
                title: {
                    text: 'é‡è¦å› å­å‘ç°',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' }
                },
                xAxis: {
                    type: 'value',
                    name: 'é‡è¦æ€§åˆ†æ•°'
                },
                yAxis: {
                    type: 'category',
                    data: names,
                    name: 'å› å­'
                },
                series: [{
                    name: 'é‡è¦æ€§',
                    type: 'bar',
                    data: scores,
                    itemStyle: {
                        color: '#f39c12'
                    },
                    label: {
                        show: true,
                        position: 'right',
                        formatter: '{c}'
                    }
                }]
            };

            myChart.setOption(option);

            // æ˜¾ç¤ºè§£è¯»
            if (results.interpretation) {
                document.getElementById('factors-interpretation').innerHTML = 
                    `<h4>ğŸ” å› å­å‘ç°è§£è¯»</h4><p>${results.interpretation}</p>`;
            }
        }

        function displayInterpretation(containerId, interpretation, title) {
            let html = `<h4>${title}</h4>`;
            
            if (interpretation.summary) {
                html += `<p><strong>æ‘˜è¦:</strong> ${interpretation.summary}</p>`;
            }
            
            if (interpretation.key_insights && interpretation.key_insights.length > 0) {
                html += '<p><strong>å…³é”®æ´å¯Ÿ:</strong></p><ul>';
                interpretation.key_insights.forEach(insight => {
                    html += `<li>${insight}</li>`;
                });
                html += '</ul>';
            }
            
            if (interpretation.business_implications) {
                html += `<p><strong>ä¸šåŠ¡å½±å“:</strong> ${interpretation.business_implications}</p>`;
            }
            
            if (interpretation.recommendations && interpretation.recommendations.length > 0) {
                html += '<p><strong>å»ºè®®:</strong></p><ul>';
                interpretation.recommendations.forEach(rec => {
                    html += `<li>${rec}</li>`;
                });
                html += '</ul>';
            }
            
            document.getElementById(containerId).innerHTML = html;
        }

        // é¡µé¢åŠ è½½ååˆ›å»ºå›¾è¡¨
        document.addEventListener('DOMContentLoaded', loadDataAndCreateCharts);
    </script>
</body>
</html>







